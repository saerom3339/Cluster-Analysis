<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Í≥†Í∞ù ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Î∂ÑÏÑù</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .upload-info {
            background: #e8f4fd;
            border: 2px dashed #36A2EB;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            color: #2c3e50;
            display: none;
        }
        
        .upload-success {
            background: #d4edda;
            border: 2px solid #28a745;
            color: #155724;
        }
        
        .upload-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            color: #721c24;
        }
        
        .charts-section {
            margin: 30px 0;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .ai-analysis-section {
            margin: 30px 0;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .ai-title {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .cluster-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .cluster-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border-left: 6px solid;
        }
        
        .cluster-card.cluster-0 { border-left-color: #FF6B6B; }
        .cluster-card.cluster-1 { border-left-color: #36A2EB; }
        .cluster-card.cluster-2 { border-left-color: #FFCE56; }
        .cluster-card.cluster-3 { border-left-color: #4BC0C0; }
        .cluster-card.cluster-4 { border-left-color: #9966FF; }
        
        .cluster-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .cluster-subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
            margin-bottom: 20px;
            font-style: italic;
        }
        
        .cluster-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .metric-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 2px;
        }
        
        .ai-insights {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .insight-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 8px;
        }
        
        .insight-text {
            color: #424242;
            line-height: 1.6;
        }
        
        .ai-strategy {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .strategy-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .data-table {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            margin-top: 30px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
        }
        
        tr:hover {
            background: #f8f9ff;
        }
        
        .cluster-0 { background-color: rgba(255, 107, 107, 0.1); }
        .cluster-1 { background-color: rgba(54, 162, 235, 0.1); }
        .cluster-2 { background-color: rgba(255, 206, 86, 0.1); }
        .cluster-3 { background-color: rgba(75, 192, 192, 0.1); }
        .cluster-4 { background-color: rgba(153, 102, 255, 0.1); }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-size: 1.2em;
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .cluster-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ AI Í∏∞Î∞ò Í≥†Í∞ù ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Î∂ÑÏÑù</h1>
        
        <div class="controls">
            <button onclick="generateData()">ÏÉà Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (1000Î™Ö)</button>
            <input type="file" id="csvFileInput" accept=".csv" onchange="handleCSVUpload(event)" style="display: none;">
            <button onclick="document.getElementById('csvFileInput').click()">üìÅ CSV ÌååÏùº ÏóÖÎ°úÎìú</button>
            <select id="clusterCount" onchange="runClustering()">
                <option value="3">3Í∞ú ÌÅ¥Îü¨Ïä§ÌÑ∞</option>
                <option value="4" selected>4Í∞ú ÌÅ¥Îü¨Ïä§ÌÑ∞</option>
                <option value="5">5Í∞ú ÌÅ¥Îü¨Ïä§ÌÑ∞</option>
            </select>
            <button onclick="runClustering()">ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Ïã§Ìñâ</button>
            <button onclick="downloadCSV()">CSV Îã§Ïö¥Î°úÎìú</button>
            <button onclick="downloadTemplate()">üìã CSV ÌÖúÌîåÎ¶ø Îã§Ïö¥Î°úÎìú</button>
        </div>
        
        <div class="stats-grid" id="statsGrid"></div>
        
        <div id="uploadStatus" class="upload-info"></div>
        
        <div class="charts-section">
            <div class="charts-container">
                <div class="chart-container">
                    <canvas id="scatterChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="barChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="ai-analysis-section" id="aiAnalysis" style="display: none;">
            <h2 class="ai-title">üß† AI Î∂ÑÏÑù Í≤∞Í≥º</h2>
            <div id="clusterAnalysis"></div>
        </div>
        
        <div class="data-table">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>Í≥†Í∞ùID</th>
                        <th>Ïù¥Î¶Ñ</th>
                        <th>Ïó∞Î†π</th>
                        <th>Ï¥ù Íµ¨Îß§Í∏àÏï°</th>
                        <th>Íµ¨Îß§ÌöüÏàò</th>
                        <th>ÌèâÍ∑† Ï£ºÎ¨∏Í∞ÄÍ≤©</th>
                        <th>ÏÑ†Ìò∏ Ïπ¥ÌÖåÍ≥†Î¶¨</th>
                        <th>RFM Ï†êÏàò</th>
                        <th>ÌÅ¥Îü¨Ïä§ÌÑ∞</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let customerData = [];
        let scatterChart, barChart;
        
        // Î∂ÑÏÇ∞ Í≥ÑÏÇ∞ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
        function calculateVariance(values) {
            if (values.length === 0) return 0;
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return variance;
        }
        
        // Ïã§Ï†ú AI Î∂ÑÏÑù Ìï®Ïàò (ÏÉÅÌíàÎ≥Ñ Íµ¨Îß§ Ìå®ÌÑ¥ Ìè¨Ìï®)
        async function analyzeClusterWithAI(clusterData, clusterStats) {
            // Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî Claude APIÎ•º Ìò∏Ï∂ú
            await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
            
            // ÏÉÅÌíàÎ≥Ñ Íµ¨Îß§ Ìå®ÌÑ¥ÏùÑ Ìè¨Ìï®Ìïú Ï¢ÖÌï© Î∂ÑÏÑù
            const insights = generateAdvancedDataDrivenInsights(clusterData, clusterStats);
            return insights;
        }
        
        // Í≥†Í∏â Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Ïù∏ÏÇ¨Ïù¥Ìä∏ ÏÉùÏÑ± (ÏÉÅÌíà Î†àÎ≤® Î∂ÑÏÑù Ìè¨Ìï®)
        function generateAdvancedDataDrivenInsights(clusterData, clusterStats) {
            const { clusterId, count, percentage } = clusterStats;
            
            // Í∏∞Î≥∏ ÌÜµÍ≥Ñ
            const avgAge = clusterData.reduce((sum, c) => sum + c.age, 0) / count;
            const avgSpent = clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / count;
            const avgPurchases = clusterData.reduce((sum, c) => sum + c.purchaseCount, 0) / count;
            const avgDaysSince = clusterData.reduce((sum, c) => sum + c.daysSinceLastPurchase, 0) / count;
            
            // ÏÉÅÌíàÎ≥Ñ Íµ¨Îß§ Ìå®ÌÑ¥ Ïã¨Ï∏µ Î∂ÑÏÑù
            const productAnalysis = analyzeProductPatterns(clusterData);
            const categoryAnalysis = analyzeCategoryPatterns(clusterData);
            const purchaseBehavior = analyzePurchaseBehavior(clusterData);
            const priceAnalysis = analyzePricePatterns(clusterData);
            
            // RFM Ï†êÏàò Î∂ÑÌè¨
            const rfmScores = clusterData.map(c => 
                (c.recencyScore || 0) + (c.frequencyScore || 0) + (c.monetaryScore || 0)
            );
            const avgRFM = rfmScores.reduce((sum, score) => sum + score, 0) / rfmScores.length;
            
            // AI Ïä§ÌÉÄÏùº Ï¢ÖÌï© Î∂ÑÏÑù
            const name = generateAdvancedClusterName(
                avgRFM, avgSpent, avgPurchases, avgAge, 
                productAnalysis, categoryAnalysis, purchaseBehavior, clusterData
            );
            
            const insights = generateComprehensiveInsights(
                avgAge, avgSpent, avgPurchases, avgDaysSince, avgRFM, 
                productAnalysis, categoryAnalysis, purchaseBehavior, priceAnalysis, percentage
            );
            
            const strategy = generateDetailedStrategy(
                name, productAnalysis, categoryAnalysis, purchaseBehavior, avgAge
            );
            
            return { name, insights, strategy };
        }
        
        // ÏÉÅÌíàÎ≥Ñ Íµ¨Îß§ Ìå®ÌÑ¥ Î∂ÑÏÑù (ÏïàÏ†ÑÌïú Ï≤òÎ¶¨)
        function analyzeProductPatterns(clusterData) {
            try {
                const productFreq = {};
                const productRevenue = {};
                let totalProducts = 0;
                
                clusterData.forEach(customer => {
                    if (customer.purchases && Array.isArray(customer.purchases)) {
                        customer.purchases.forEach(purchase => {
                            if (purchase && purchase.product && purchase.amount) {
                                const product = purchase.product || 'Ïïå Ïàò ÏóÜÏùå';
                                const amount = parseFloat(purchase.amount) || 0;
                                
                                productFreq[product] = (productFreq[product] || 0) + 1;
                                productRevenue[product] = (productRevenue[product] || 0) + amount;
                                totalProducts++;
                            }
                        });
                    }
                });
                
                if (totalProducts === 0) {
                    return {
                        topProducts: [],
                        topRevenueProducts: [],
                        uniqueProductCount: 0,
                        totalPurchases: 0
                    };
                }
                
                // Ïù∏Í∏∞ ÏÉÅÌíà TOP 3
                const topProducts = Object.entries(productFreq)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([product, count]) => ({
                        product,
                        count,
                        percentage: Math.round(count / totalProducts * 100)
                    }));
                
                // Í≥†ÏàòÏùµ ÏÉÅÌíà TOP 3
                const topRevenueProducts = Object.entries(productRevenue)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([product, revenue]) => ({
                        product,
                        revenue,
                        avgPrice: Math.round(revenue / (productFreq[product] || 1))
                    }));
                
                return {
                    topProducts,
                    topRevenueProducts,
                    uniqueProductCount: Object.keys(productFreq).length,
                    totalPurchases: totalProducts
                };
            } catch (error) {
                console.warn('ÏÉÅÌíà Ìå®ÌÑ¥ Î∂ÑÏÑù Ïò§Î•ò:', error);
                return {
                    topProducts: [],
                    topRevenueProducts: [],
                    uniqueProductCount: 0,
                    totalPurchases: 0
                };
            }
        }
        
        // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Íµ¨Îß§ Ìå®ÌÑ¥ Î∂ÑÏÑù
        function analyzeCategoryPatterns(clusterData) {
            const categoryFreq = {};
            const categorySpend = {};
            let totalSpend = 0;
            
            clusterData.forEach(customer => {
                if (customer.purchases) {
                    customer.purchases.forEach(purchase => {
                        const category = purchase.category || 'Í∏∞ÌÉÄ';
                        categoryFreq[category] = (categoryFreq[category] || 0) + 1;
                        categorySpend[category] = (categorySpend[category] || 0) + purchase.amount;
                        totalSpend += purchase.amount;
                    });
                }
            });
            
            // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏßÄÏ∂ú ÎπÑÏú®
            const categoryDistribution = Object.entries(categorySpend)
                .sort(([,a], [,b]) => b - a)
                .map(([category, spend]) => ({
                    category,
                    spend,
                    percentage: Math.round(spend / totalSpend * 100),
                    avgOrderValue: Math.round(spend / (categoryFreq[category] || 1))
                }));
            
            // Ïπ¥ÌÖåÍ≥†Î¶¨ ÏßëÏ§ëÎèÑ (ÌóàÌïÄÎã¨ ÏßÄÏàò)
            const concentration = categoryDistribution.reduce((sum, cat) => 
                sum + Math.pow(cat.percentage / 100, 2), 0
            );
            
            return {
                distribution: categoryDistribution,
                concentration: concentration,
                diversityScore: Math.round((1 - concentration) * 100),
                dominantCategory: categoryDistribution[0]?.category || 'ÏóÜÏùå'
            };
        }
        
        // Íµ¨Îß§ ÌñâÎèô Ìå®ÌÑ¥ Î∂ÑÏÑù (ÏïàÏ†ÑÌïú Ï≤òÎ¶¨)
        function analyzePurchaseBehavior(clusterData) {
            try {
                const behaviors = {
                    impulseBuyers: 0,
                    plannedBuyers: 0,
                    loyalBuyers: 0,
                    explorers: 0
                };
                
                clusterData.forEach(customer => {
                    if (customer.purchases && Array.isArray(customer.purchases) && customer.purchases.length > 1) {
                        try {
                            // Íµ¨Îß§ Í∞ÑÍ≤© Î∂ÑÏÑù
                            const intervals = [];
                            const sortedPurchases = customer.purchases
                                .filter(p => p && p.date && p.date !== '')
                                .sort((a, b) => {
                                    try {
                                        return new Date(a.date) - new Date(b.date);
                                    } catch {
                                        return 0;
                                    }
                                });
                            
                            for (let i = 1; i < sortedPurchases.length; i++) {
                                try {
                                    const interval = (new Date(sortedPurchases[i].date) - new Date(sortedPurchases[i-1].date)) / (1000 * 60 * 60 * 24);
                                    if (!isNaN(interval) && interval >= 0) {
                                        intervals.push(interval);
                                    }
                                } catch {
                                    // ÎÇ†Ïßú ÌååÏã± Ïò§Î•ò Î¨¥Ïãú
                                }
                            }
                            
                            const avgInterval = intervals.length > 0 ? 
                                intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length : 30;
                            const intervalVariance = intervals.length > 1 ? calculateVariance(intervals) : 100;
                            
                            // ÏÉÅÌíà Îã§ÏñëÏÑ±
                            const uniqueProducts = new Set(customer.purchases.map(p => p.product || 'Ïïå Ïàò ÏóÜÏùå')).size;
                            const productLoyalty = customer.purchases.length / Math.max(uniqueProducts, 1);
                            
                            // ÌñâÎèô Ïú†Ìòï Î∂ÑÎ•ò
                            if (avgInterval < 7 && intervalVariance > 50) {
                                behaviors.impulseBuyers++;
                            } else if (avgInterval > 30 && intervalVariance < 100) {
                                behaviors.plannedBuyers++;
                            } else if (productLoyalty > 2) {
                                behaviors.loyalBuyers++;
                            } else {
                                behaviors.explorers++;
                            }
                        } catch (error) {
                            console.warn('Í∞úÎ≥Ñ Í≥†Í∞ù ÌñâÎèô Î∂ÑÏÑù Ïò§Î•ò:', error);
                            behaviors.explorers++; // Í∏∞Î≥∏Í∞í
                        }
                    } else {
                        behaviors.explorers++; // Í∏∞Î≥∏Í∞í
                    }
                });
                
                const total = Object.values(behaviors).reduce((sum, count) => sum + count, 0);
                const behaviorDistribution = {};
                Object.keys(behaviors).forEach(behavior => {
                    behaviorDistribution[behavior] = total > 0 ? Math.round(behaviors[behavior] / total * 100) : 25;
                });
                
                return {
                    distribution: behaviorDistribution,
                    dominantBehavior: Object.keys(behaviorDistribution).reduce((a, b) => 
                        behaviorDistribution[a] > behaviorDistribution[b] ? a : b
                    )
                };
            } catch (error) {
                console.warn('Íµ¨Îß§ ÌñâÎèô Î∂ÑÏÑù Ïò§Î•ò:', error);
                return {
                    distribution: { impulseBuyers: 25, plannedBuyers: 25, loyalBuyers: 25, explorers: 25 },
                    dominantBehavior: 'explorers'
                };
            }
        }
        
        // Í∞ÄÍ≤© Ìå®ÌÑ¥ Î∂ÑÏÑù
        function analyzePricePatterns(clusterData) {
            const allPrices = [];
            clusterData.forEach(customer => {
                if (customer.purchases) {
                    customer.purchases.forEach(purchase => {
                        allPrices.push(purchase.amount);
                    });
                }
            });
            
            if (allPrices.length === 0) return { sensitivity: 'unknown', pattern: 'insufficient_data' };
            
            allPrices.sort((a, b) => a - b);
            const median = allPrices[Math.floor(allPrices.length / 2)];
            const q1 = allPrices[Math.floor(allPrices.length * 0.25)];
            const q3 = allPrices[Math.floor(allPrices.length * 0.75)];
            const iqr = q3 - q1;
            const priceVariance = calculateVariance(allPrices);
            
            let sensitivity, pattern;
            if (priceVariance < 100000) {
                sensitivity = 'ÏùºÍ¥ÄÎêú Í∞ÄÍ≤©ÎåÄ ÏÑ†Ìò∏';
                pattern = 'consistent';
            } else if (iqr > median) {
                sensitivity = 'Í∞ÄÍ≤© ÌÉÑÎ†•Ï†Å';
                pattern = 'flexible';
            } else {
                sensitivity = 'Í∞ÄÍ≤© ÎØºÍ∞êÌòï';
                pattern = 'sensitive';
            }
            
            return {
                median: median,
                iqr: iqr,
                variance: priceVariance,
                sensitivity: sensitivity,
                pattern: pattern
            };
        }
        
        // Í≥†Í∏â ÌÅ¥Îü¨Ïä§ÌÑ∞ Î™ÖÎ™Ö - Î≤°ÌÑ∞ Í∏∞Î∞ò ÌäπÏÑ± Î∂ÑÏÑù
        function generateAdvancedClusterName(rfm, spent, purchases, age, productAnalysis, categoryAnalysis, purchaseBehavior, clusterData) {
            // ÌÅ¥Îü¨Ïä§ÌÑ∞Ïùò Ïã§Ï†ú ÌäπÏÑ±ÏùÑ Í∏∞Î∞òÏúºÎ°ú Ìïú Îã§Ï∞®Ïõê Î∂ÑÏÑù
            const features = {
                rfmScore: rfm,
                spendingLevel: spent,
                purchaseFrequency: purchases,
                ageGroup: age,
                dominantCategory: categoryAnalysis.dominantCategory,
                categoryDiversity: categoryAnalysis.diversityScore,
                behaviorType: purchaseBehavior.dominantBehavior,
                productVariety: productAnalysis.uniqueProductCount,
                priceRange: analyzePricePatterns(clusterData).pattern
            };
            
            // ÌÅ¥Îü¨Ïä§ÌÑ∞Ïùò Ï£ºÏöî ÌäπÏÑ± Î≤°ÌÑ∞ Í≥ÑÏÇ∞
            const characteristicVector = calculateCharacteristicVector(features);
            
            // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌäπÏÑ± Ï†êÏàò Í∏∞Î∞ò Î™ÖÎ™Ö
            return generateDataDrivenClusterName(characteristicVector, features);
        }
        
        // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌäπÏÑ± Î≤°ÌÑ∞ Í≥ÑÏÇ∞
        function calculateCharacteristicVector(features) {
            const vector = {
                luxuryScore: 0,
                loyaltyScore: 0,
                diversityScore: 0,
                valueScore: 0,
                frequencyScore: 0,
                techScore: 0,
                familyScore: 0,
                trendScore: 0
            };
            
            // Luxury Score (Í≥†Í∏â ÏÜåÎπÑ ÏÑ±Ìñ•)
            vector.luxuryScore = (features.spendingLevel / 1000000) * 0.4 + 
                                (features.rfmScore / 15) * 0.3 +
                                (features.priceRange === 'flexible' ? 0.3 : 0);
            
            // Loyalty Score (Ï∂©ÏÑ±ÎèÑ)
            vector.loyaltyScore = (features.behaviorType === 'loyalBuyers' ? 0.5 : 0) +
                                 (features.purchaseFrequency / 30) * 0.3 +
                                 (features.categoryDiversity < 30 ? 0.2 : 0);
            
            // Diversity Score (Îã§ÏñëÏÑ± Ï∂îÍµ¨)
            vector.diversityScore = (features.categoryDiversity / 100) * 0.4 +
                                   (features.productVariety / 50) * 0.3 +
                                   (features.behaviorType === 'explorers' ? 0.3 : 0);
            
            // Value Score (Í∞ÄÏπò Ï∂îÍµ¨)
            vector.valueScore = (features.spendingLevel < 300000 ? 0.4 : 0) +
                               (features.priceRange === 'sensitive' ? 0.3 : 0) +
                               (features.ageGroup < 35 ? 0.3 : 0);
            
            // Frequency Score (Íµ¨Îß§ ÎπàÎèÑ)
            vector.frequencyScore = Math.min(features.purchaseFrequency / 20, 1);
            
            // Tech Score (Í∏∞Ïà† ÏπúÌôîÎèÑ)
            vector.techScore = (features.dominantCategory === 'Ï†ÑÏûêÏ†úÌíà' ? 0.6 : 0) +
                              (features.ageGroup < 40 ? 0.4 : 0);
            
            // Family Score (Í∞ÄÏ°± Ï§ëÏã¨)
            vector.familyScore = (features.dominantCategory === 'Ïú†Ï†úÌíà' ? 0.3 : 0) +
                                (features.dominantCategory === 'ÏÉùÌôúÏö©Ìíà' ? 0.3 : 0) +
                                (features.ageGroup > 35 ? 0.4 : 0);
            
            // Trend Score (Ìä∏Î†åÎìú ÎØºÍ∞êÎèÑ)
            vector.trendScore = (features.dominantCategory === 'ÏùòÎ•ò' ? 0.4 : 0) +
                               (features.behaviorType === 'impulseBuyers' ? 0.3 : 0) +
                               (features.ageGroup < 35 ? 0.3 : 0);
            
            return vector;
        }
        
        // Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò ÌÅ¥Îü¨Ïä§ÌÑ∞ Ïù¥Î¶Ñ ÏÉùÏÑ±
        function generateDataDrivenClusterName(vector, features) {
            // Í∞ÄÏû• ÎÜíÏùÄ ÌäπÏÑ± Ï†êÏàò Ï∞æÍ∏∞
            const scores = Object.entries(vector).sort(([,a], [,b]) => b - a);
            const primaryTrait = scores[0][0];
            const secondaryTrait = scores[1][0];
            const primaryScore = scores[0][1];
            const secondaryScore = scores[1][1];
            
            // Î≥µÌï© ÌäπÏÑ± Í∏∞Î∞ò Î™ÖÎ™Ö
            if (primaryScore > 0.8) {
                // Îã®Ïùº ÌäπÏÑ±Ïù¥ Îß§Ïö∞ Í∞ïÌïú Í≤ΩÏö∞
                const strongNames = {
                    luxuryScore: "üëë ÌîÑÎ¶¨ÎØ∏ÏóÑ VIP",
                    loyaltyScore: "üíé Ï∂©ÏÑ± Í≥†Í∞ùÍµ∞",
                    diversityScore: "üåà Îã§ÏñëÏÑ± Ï∂îÍµ¨Ïûê",
                    valueScore: "üí∞ Í∞ÄÏπò Ï§ëÏãúÌòï",
                    frequencyScore: "‚ö° ÏÉÅÏãú Íµ¨Îß§Ïûê",
                    techScore: "üîå ÌÖåÌÅ¨ Ïï†Ìò∏Í∞Ä",
                    familyScore: "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Ìå®Î∞ÄÎ¶¨ ÏºÄÏñ¥",
                    trendScore: "‚ú® Ìä∏Î†åÎìú ÏÑ∏ÌÑ∞"
                };
                return strongNames[primaryTrait] || "‚≠ê ÏùºÎ∞ò Í≥†Í∞ù";
            }
            
            // Î≥µÌï© ÌäπÏÑ± Ï°∞Ìï©
            const combinedName = getCombinedClusterName(primaryTrait, secondaryTrait, features);
            return combinedName;
        }
        
        // Î≥µÌï© ÌäπÏÑ± Í∏∞Î∞ò ÌÅ¥Îü¨Ïä§ÌÑ∞ Î™ÖÎ™Ö
        function getCombinedClusterName(primary, secondary, features) {
            const combinations = {
                'luxuryScore_loyaltyScore': "üëë ÌîÑÎ¶¨ÎØ∏ÏóÑ Î°úÏó¥Ìã∞Ïä§Ìä∏",
                'luxuryScore_diversityScore': "üíé Îü≠ÏÖîÎ¶¨ ÏùµÏä§ÌîåÎ°úÎü¨",
                'loyaltyScore_frequencyScore': "üèÜ ÏäàÌçº Îã®Í≥®Í≥†Í∞ù",
                'loyaltyScore_familyScore': "üë®‚Äçüë©‚Äçüëß Ìå®Î∞ÄÎ¶¨ Ï†ïÏ∞©Ìòï",
                'diversityScore_trendScore': "üéØ Ìä∏Î†åÎìú ÌóåÌÑ∞",
                'diversityScore_valueScore': "üõçÔ∏è Ïä§ÎßàÌä∏ ÏáºÌçº",
                'valueScore_frequencyScore': "üí∏ Ïã§ÏÜçÌòï ÏÉÅÏãúÍ≥†Í∞ù",
                'valueScore_familyScore': "üë∂ ÏïåÎú∞ Ìå®Î∞ÄÎ¶¨",
                'techScore_luxuryScore': "üöÄ ÌÖåÌÅ¨ ÌîÑÎ¶¨ÎØ∏ÏóÑ",
                'techScore_trendScore': "üì± ÎîîÏßÄÌÑ∏ Ìä∏Î†åÎìúÏÑ∏ÌÑ∞",
                'familyScore_frequencyScore': "üè† ÏÉùÌôúÎ∞ÄÏ∞©Ìòï",
                'trendScore_frequencyScore': "‚ö° Ìä∏Î†åÎìú ÌÄµÎ∞îÏù¥Ïñ¥"
            };
            
            const key = `${primary}_${secondary}`;
            const reverseKey = `${secondary}_${primary}`;
            
            // Ïó∞Î†πÍ≥º ÏßÄÏ∂ú ÌäπÏÑ±ÏùÑ Ï∂îÍ∞ÄÎ°ú Í≥†Î†§
            if (features.ageGroup < 30 && features.spendingLevel < 200000) {
                return "üå± ÏòÅ Ïä§ÎßàÌä∏ Ïª®ÏäàÎ®∏";
            }
            if (features.ageGroup > 50 && features.purchaseFrequency > 15) {
                return "üéñÔ∏è ÏãúÎãàÏñ¥ VIP";
            }
            
            return combinations[key] || combinations[reverseKey] || "‚≠ê Í∑†ÌòïÌòï Í≥†Í∞ù";
        }
        
        // Ï¢ÖÌï© Ïù∏ÏÇ¨Ïù¥Ìä∏ ÏÉùÏÑ±
        function generateComprehensiveInsights(age, spent, purchases, daysSince, rfm, productAnalysis, categoryAnalysis, purchaseBehavior, priceAnalysis, percentage) {
            const topProducts = productAnalysis.topProducts.map(p => `${p.product}(${p.percentage}%)`).join(', ');
            const topCategory = categoryAnalysis.distribution[0];
            const behaviorType = purchaseBehavior.dominantBehavior;
            
            const behaviorDesc = {
                'impulseBuyers': 'Ï∂©ÎèôÍµ¨Îß§Ìòï',
                'plannedBuyers': 'Í≥ÑÌöçÍµ¨Îß§Ìòï', 
                'loyalBuyers': 'Ï∂©ÏÑ±Íµ¨Îß§Ìòï',
                'explorers': 'ÌÉêÌóòÌòï'
            };
            
            return `Ïù¥ ÌÅ¥Îü¨Ïä§ÌÑ∞Îäî Ï†ÑÏ≤¥ Í≥†Í∞ùÏùò ${percentage}%Î•º Ï∞®ÏßÄÌïòÎ©∞, ÌèâÍ∑† Ïó∞Î†π ${age.toFixed(0)}ÏÑ∏Ïùò ${behaviorDesc[behaviorType]} Í≥†Í∞ùÎì§ÏûÖÎãàÎã§.
            
            üìä Íµ¨Îß§ Ìå®ÌÑ¥: Ï¥ù ${productAnalysis.uniqueProductCount}Í∞úÏùò ÏÑúÎ°ú Îã§Î•∏ ÏÉÅÌíàÏùÑ Íµ¨Îß§ÌñàÏúºÎ©∞, Ï£ºÏöî Ïù∏Í∏∞ ÏÉÅÌíàÏùÄ ${topProducts}ÏûÖÎãàÎã§. 
            ${topCategory?.category || 'Îã§ÏñëÌïú'} Ïπ¥ÌÖåÍ≥†Î¶¨ÏóêÏÑú ${topCategory?.percentage || 0}%Ïùò ÏßÄÏ∂ú ÎπÑÏ§ëÏùÑ Î≥¥Ïù¥Î©∞, Ïπ¥ÌÖåÍ≥†Î¶¨ Îã§ÏñëÏÑ± Ï†êÏàòÎäî ${categoryAnalysis.diversityScore}Ï†êÏûÖÎãàÎã§.
            
            üí∞ ÏßÄÏ∂ú ÌäπÏÑ±: ÌèâÍ∑† ${spent.toLocaleString()}ÏõêÏùÑ ÏßÄÏ∂úÌïòÍ≥† ${purchases.toFixed(1)}Ìöå Íµ¨Îß§ÌïòÏó¨ RFM Ï†êÏàò ${rfm.toFixed(1)}Ï†êÏùÑ Í∏∞Î°ùÌñàÏäµÎãàÎã§. 
            ${priceAnalysis.sensitivity} ÌäπÏÑ±ÏùÑ Î≥¥Ïù¥Î©∞, Í∞ÄÍ≤© Ï§ëÏúÑÍ∞íÏùÄ ${priceAnalysis.median?.toLocaleString() || 0}ÏõêÏûÖÎãàÎã§.
            
            üéØ ÌñâÎèô ÌäπÏÑ±: ${behaviorDesc[behaviorType]} Í≥†Í∞ùÏù¥ ${purchaseBehavior.distribution[behaviorType]}%Î•º Ï∞®ÏßÄÌïòÎ©∞, 
            ÏµúÍ∑º Íµ¨Îß§Î°úÎ∂ÄÌÑ∞ ÌèâÍ∑† ${daysSince.toFixed(0)}ÏùºÏù¥ Í≤ΩÍ≥ºÌñàÏäµÎãàÎã§.`;
        }
        
        // ÏÉÅÏÑ∏ Ï†ÑÎûµ ÏÉùÏÑ±
        function generateDetailedStrategy(name, productAnalysis, categoryAnalysis, purchaseBehavior, age) {
            const topProduct = productAnalysis.topProducts[0]?.product;
            const topCategory = categoryAnalysis.distribution[0]?.category;
            const behavior = purchaseBehavior.dominantBehavior;
            
            const strategies = [];
            
            // ÏÉÅÌíà Í∏∞Î∞ò Ï†ÑÎûµ
            if (topProduct) {
                strategies.push(`${topProduct} ÏÉÅÌíàÍµ∞ Ï§ëÏã¨Ïùò ÌÅ¨Î°úÏä§ÏÖÄÎßÅ Î∞è ÏóÖÏÖÄÎßÅ Ï†ÑÎûµ Ïã§Ìñâ`);
            }
            
            // Ïπ¥ÌÖåÍ≥†Î¶¨ Í∏∞Î∞ò Ï†ÑÎûµ
            if (topCategory && categoryAnalysis.concentration > 0.4) {
                strategies.push(`${topCategory} Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ÑÎ¨∏ÏÑ±ÏùÑ Ïñ¥ÌïÑÌïòÎäî ÌÅêÎ†àÏù¥ÏÖò ÏÑúÎπÑÏä§ Ï†úÍ≥µ`);
            } else {
                strategies.push(`Îã§ÏñëÌïú Ïπ¥ÌÖåÍ≥†Î¶¨ Î≤àÎì§ÎßÅÏùÑ ÌÜµÌïú ÌÅ¨Î°úÏä§ Ïπ¥ÌÖåÍ≥†Î¶¨ Îß§Ï∂ú Ï¶ùÎåÄ`);
            }
            
            // ÌñâÎèô Ìå®ÌÑ¥ Í∏∞Î∞ò Ï†ÑÎûµ
            const behaviorStrategies = {
                'impulseBuyers': 'Ïã§ÏãúÍ∞Ñ Í∞úÏù∏Ìôî Ï∂îÏ≤úÍ≥º ÌïúÏ†ïÏãúÍ∞Ñ Ìï†Ïù∏ÏúºÎ°ú Íµ¨Îß§ Ï∂©Îèô ÏûêÍ∑π',
                'plannedBuyers': 'Ï†ïÍ∏∞ Ï£ºÎ¨∏ ÏãúÏä§ÌÖúÍ≥º ÎØ∏Î¶¨ ÏïåÎ¶º ÏÑúÎπÑÏä§Î°ú Íµ¨Îß§ Ìé∏ÏùòÏÑ± Ï†úÍ≥†',
                'loyalBuyers': 'Î∏åÎûúÎìú Ï∂©ÏÑ±ÎèÑ Î¶¨ÏõåÎìú ÌîÑÎ°úÍ∑∏Îû®Í≥º VIP ÌòúÌÉùÏúºÎ°ú Í¥ÄÍ≥Ñ Ïã¨Ìôî',
                'explorers': 'Ïã†Ï†úÌíà Ïö∞ÏÑ† Ï≤¥ÌóòÍ≥º Îã§ÏñëÏÑ± Ï∂îÍµ¨ ÎßûÏ∂§ Ï∂îÏ≤úÏúºÎ°ú ÌÉêÌóò ÏöïÍµ¨ Ï∂©Ï°±'
            };
            strategies.push(behaviorStrategies[behavior]);
            
            // Ïó∞Î†π Í∏∞Î∞ò Ï†ÑÎûµ
            if (age < 35) {
                strategies.push('ÏÜåÏÖúÎØ∏ÎîîÏñ¥ ÎßàÏºÄÌåÖÍ≥º Ïù∏ÌîåÎ£®Ïñ∏ÏÑú ÌòëÏóÖÏùÑ ÌÜµÌïú Ï†äÏùÄ Í≥†Í∞ùÏ∏µ engagement Í∞ïÌôî');
            } else {
                strategies.push('Ïã†Î¢∞ÏÑ±Í≥º ÌíàÏßàÏùÑ Í∞ïÏ°∞Ìïú Ï†ÑÌÜµÏ†Å ÎßàÏºÄÌåÖ Ï±ÑÎÑê ÌôúÏö©');
            }
            
            return strategies.slice(0, 4).join('. ') + '.';
        }
        
        // CSV ÌååÏùº ÏóÖÎ°úÎìú Ï≤òÎ¶¨
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            showUploadStatus('üì§ CSV ÌååÏùºÏùÑ Î∂ÑÏÑù Ï§ëÏûÖÎãàÎã§...', 'info');
            
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                encoding: 'UTF-8',
                complete: function(results) {
                    try {
                        const processedData = processCSVData(results.data);
                        if (processedData && processedData.length > 0) {
                            customerData = processedData;
                            showUploadStatus(`‚úÖ ${processedData.length}Î™ÖÏùò Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞Î•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎ°úÎìúÌñàÏäµÎãàÎã§!`, 'success');
                            updateStats();
                            updateTable();
                            runClustering();
                        } else {
                            throw new Error('Ïú†Ìö®Ìïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                        }
                    } catch (error) {
                        showUploadStatus(`‚ùå ÌååÏùº Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`, 'error');
                        console.error('CSV Ï≤òÎ¶¨ Ïò§Î•ò:', error);
                    }
                },
                error: function(error) {
                    showUploadStatus(`‚ùå ÌååÏùº ÏùΩÍ∏∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}`, 'error');
                    console.error('CSV ÌååÏã± Ïò§Î•ò:', error);
                }
            });
        }
        
        // CSV Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î∞è Î≥ÄÌôò (ÏÉÅÌíàÎ≥Ñ Íµ¨Îß§ Ïù¥Î†• ‚Üí Í≥†Í∞ùÎ≥Ñ ÏßëÍ≥Ñ)
        function processCSVData(rawData) {
            const customerGroups = {};
            
            rawData.forEach((row, index) => {
                try {
                    const cleanRow = {};
                    Object.keys(row).forEach(key => {
                        const cleanKey = key.trim().toLowerCase().replace(/\s+/g, '');
                        cleanRow[cleanKey] = row[key];
                    });
                    
                    const customerId = cleanRow['Í≥†Í∞ùid'] || cleanRow['customerid'] || cleanRow['id'] || index + 1;
                    const customerName = cleanRow['Ïù¥Î¶Ñ'] || cleanRow['name'] || cleanRow['Í≥†Í∞ùÎ™Ö'] || `Í≥†Í∞ù${customerId}`;
                    const age = parseInt(cleanRow['Ïó∞Î†π'] || cleanRow['age']) || 0;
                    const purchaseAmount = parseFloat(cleanRow['1ÌöåÍµ¨Îß§Í∞ÄÍ≤©'] || cleanRow['Íµ¨Îß§Í∏àÏï°'] || cleanRow['Í∞ÄÍ≤©']) || 0;
                    const product = cleanRow['Íµ¨Îß§ÏÉÅÌíà'] || cleanRow['ÏÉÅÌíà'] || cleanRow['product'] || 'Ïïå Ïàò ÏóÜÏùå';
                    const category = cleanRow['Ïπ¥ÌÖåÍ≥†Î¶¨'] || cleanRow['category'] || cleanRow['Î∂ÑÎ•ò'] || 'Í∏∞ÌÉÄ';
                    const purchaseDate = cleanRow['Íµ¨Îß§Ïùº'] || cleanRow['date'] || cleanRow['purchase_date'] || '2024-01-01';
                    
                    if (!customerId || purchaseAmount <= 0) return;
                    
                    if (!customerGroups[customerId]) {
                        customerGroups[customerId] = {
                            id: customerId,
                            name: customerName,
                            age: age || 0,
                            purchases: [],
                            categories: new Set(),
                            products: new Set()
                        };
                    }
                    
                    customerGroups[customerId].purchases.push({
                        amount: purchaseAmount,
                        product: product,
                        category: category,
                        date: purchaseDate
                    });
                    
                    customerGroups[customerId].categories.add(category);
                    customerGroups[customerId].products.add(product);
                    
                    if (!customerGroups[customerId].age && age > 0) {
                        customerGroups[customerId].age = age;
                    }
                } catch (error) {
                    console.warn(`Ìñâ ${index + 1} Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:`, error);
                }
            });
            
            const today = new Date();
            const processedCustomers = Object.values(customerGroups).map(customer => {
                try {
                    const purchases = customer.purchases || [];
                    if (purchases.length === 0) return null;
                    
                    const frequency = purchases.length;
                    const monetary = purchases.reduce((sum, p) => sum + (p.amount || 0), 0);
                    const avgOrderValue = frequency > 0 ? Math.round(monetary / frequency) : 0;
                    
                    let recency = 180;
                    const dates = purchases.map(p => p.date).filter(d => d && d !== '');
                    if (dates.length > 0) {
                        try {
                            const latestDate = new Date(Math.max(...dates.map(d => new Date(d))));
                            if (!isNaN(latestDate.getTime())) {
                                recency = Math.floor((today - latestDate) / (1000 * 60 * 60 * 24));
                            }
                        } catch (dateError) {
                            console.warn('ÎÇ†Ïßú Ï≤òÎ¶¨ Ïò§Î•ò:', dateError);
                            recency = Math.floor(Math.random() * 180) + 1;
                        }
                    }
                    
                    const lastPurchaseDate = dates.length > 0 ? dates[dates.length - 1] : 
                        new Date(today.getTime() - recency * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    
                    const categoryDiversity = customer.categories ? customer.categories.size : 1;
                    const productDiversity = customer.products ? customer.products.size : 1;
                    const avgPurchaseInterval = frequency > 1 ? Math.round(recency / (frequency - 1)) : recency;
                    
                    const categoryCount = {};
                    purchases.forEach(p => {
                        const cat = p.category || 'Í∏∞ÌÉÄ';
                        categoryCount[cat] = (categoryCount[cat] || 0) + 1;
                    });
                    const favoriteCategory = Object.keys(categoryCount).length > 0 ? 
                        Object.keys(categoryCount).reduce((a, b) => categoryCount[a] > categoryCount[b] ? a : b, 'Í∏∞ÌÉÄ') : 'Í∏∞ÌÉÄ';
                    
                    return {
                        id: customer.id,
                        name: customer.name || `Í≥†Í∞ù${customer.id}`,
                        age: Math.max(18, Math.min(80, customer.age)) || Math.floor(Math.random() * 40) + 25,
                        totalSpent: monetary,
                        purchaseCount: frequency,
                        avgOrderValue: avgOrderValue,
                        daysSinceLastPurchase: Math.max(0, recency),
                        lastPurchaseDate: lastPurchaseDate,
                        categoryDiversity: categoryDiversity,
                        productDiversity: productDiversity,
                        favoriteCategory: favoriteCategory,
                        avgPurchaseInterval: avgPurchaseInterval,
                        recencyScore: 0,
                        frequencyScore: 0,
                        monetaryScore: 0,
                        cluster: null,
                        purchases: purchases
                    };
                } catch (error) {
                    console.warn('Í≥†Í∞ù Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ïò§Î•ò:', error);
                    return null;
                }
            }).filter(customer => customer !== null);
            
            if (processedCustomers.length > 0) {
                try {
                    calculateRFMScores(processedCustomers);
                } catch (error) {
                    console.warn('RFM Ï†êÏàò Í≥ÑÏÇ∞ Ïò§Î•ò:', error);
                }
            }
            
            return processedCustomers;
        }
        
        // RFM Ï†êÏàò Í≥ÑÏÇ∞ (ÏïàÏ†ÑÌïú Ï≤òÎ¶¨)
        function calculateRFMScores(customers) {
            try {
                const recencyValues = customers.map(c => c.daysSinceLastPurchase || 0).sort((a, b) => a - b);
                const frequencyValues = customers.map(c => c.purchaseCount || 0).sort((a, b) => b - a);
                const monetaryValues = customers.map(c => c.totalSpent || 0).sort((a, b) => b - a);
                
                const getQuintile = (value, values, reverse = false) => {
                    if (values.length === 0) return 3;
                    const index = values.indexOf(value);
                    if (index === -1) return 3;
                    let quintile = Math.ceil((index + 1) / values.length * 5);
                    quintile = Math.max(1, Math.min(5, quintile));
                    return reverse ? 6 - quintile : quintile;
                };
                
                customers.forEach(customer => {
                    customer.recencyScore = getQuintile(customer.daysSinceLastPurchase || 0, recencyValues, true);
                    customer.frequencyScore = getQuintile(customer.purchaseCount || 0, frequencyValues);
                    customer.monetaryScore = getQuintile(customer.totalSpent || 0, monetaryValues);
                });
            } catch (error) {
                console.warn('RFM Ï†êÏàò Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò:', error);
                // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
                customers.forEach(customer => {
                    customer.recencyScore = 3;
                    customer.frequencyScore = 3;
                    customer.monetaryScore = 3;
                });
            }
        }
        
        // ÏóÖÎ°úÎìú ÏÉÅÌÉú ÌëúÏãú
        function showUploadStatus(message, type) {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.textContent = message;
            statusDiv.className = `upload-info upload-${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        // Í∞ÄÏßú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        function generateData() {
            customerData = [];
            const surnames = ['ÍπÄ', 'Ïù¥', 'Î∞ï', 'Ïµú', 'Ï†ï', 'Í∞ï', 'ÏÜê', 'Ï°∞', 'Ïú§', 'Ïû•'];
            const givenNames = ['ÎØºÏàò', 'ÏòÅÌù¨', 'Ï≤†Ïàò', 'ÏòÅÏàò', 'ÎØºÏïÑ', 'ÌÉúÏßÑ', 'ÎØ∏Í≤Ω', 'ÌòÑÏö∞', 'ÏÑúÏó∞', 'ÎèôÌòÅ'];
            const categories = ['Ï±ÑÏÜå', 'Í≥ºÏùº', 'Ïú°Î•ò', 'Ïú†Ï†úÌíà', 'Ï¶âÏÑùÏãùÌíà', 'ÏÉùÌôúÏö©Ìíà', 'ÏùòÎ•ò', 'Ï†ÑÏûêÏ†úÌíà'];
            const products = {
                'Ï±ÑÏÜå': ['ÎãπÍ∑º', 'ÏãúÍ∏àÏπò', 'ÏñëÌåå', 'Î∏åÎ°úÏΩúÎ¶¨', 'ÏÉÅÏ∂î'],
                'Í≥ºÏùº': ['ÏÇ¨Í≥º', 'Î∞îÎÇòÎÇò', 'Ïò§Î†åÏßÄ', 'Îî∏Í∏∞', 'Ìè¨ÎèÑ'],
                'Ïú°Î•ò': ['ÏÜåÍ≥†Í∏∞', 'ÎèºÏßÄÍ≥†Í∏∞', 'Îã≠Í≥†Í∏∞', 'Ïò§Î¶¨Í≥†Í∏∞'],
                'Ïú†Ï†úÌíà': ['Ïö∞Ïú†', 'ÏöîÍ±∞Ìä∏', 'ÏπòÏ¶à', 'Î≤ÑÌÑ∞'],
                'Ï¶âÏÑùÏãùÌíà': ['ÎùºÎ©¥', 'ÍπÄÎ∞•', 'ÎèÑÏãúÎùΩ', 'ÌñÑÎ≤ÑÍ±∞'],
                'ÏÉùÌôúÏö©Ìíà': ['ÏÑ∏Ï†ú', 'ÌôîÏû•ÏßÄ', 'ÏÉ¥Ìë∏', 'ÏπòÏïΩ'],
                'ÏùòÎ•ò': ['Ìã∞ÏÖîÏ∏†', 'Ï≤≠Î∞îÏßÄ', 'ÏõêÌîºÏä§', 'ÏûêÏºì'],
                'Ï†ÑÏûêÏ†úÌíà': ['Ïä§ÎßàÌä∏Ìè∞', 'ÎÖ∏Ìä∏Î∂Å', 'Ïù¥Ïñ¥Ìè∞', 'Ï∂©Ï†ÑÍ∏∞']
            };
            
            for (let i = 1; i <= 1000; i++) {
                const surname = surnames[Math.floor(Math.random() * surnames.length)];
                const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
                
                const ageGroup = Math.random();
                let age, purchases = [];
                
                if (ageGroup < 0.2) {
                    age = Math.floor(Math.random() * 10) + 20;
                } else if (ageGroup < 0.5) {
                    age = Math.floor(Math.random() * 10) + 30;
                } else if (ageGroup < 0.8) {
                    age = Math.floor(Math.random() * 10) + 40;
                } else {
                    age = Math.floor(Math.random() * 20) + 50;
                }
                
                // Ïó∞Î†πÎåÄÎ≥Ñ Íµ¨Îß§ Ìå®ÌÑ¥ ÏÉùÏÑ±
                const purchaseCount = Math.floor(Math.random() * 20) + 3;
                for (let j = 0; j < purchaseCount; j++) {
                    const category = categories[Math.floor(Math.random() * categories.length)];
                    const productList = products[category];
                    const product = productList[Math.floor(Math.random() * productList.length)];
                    const amount = Math.floor(Math.random() * 50000) + 5000;
                    const daysAgo = Math.floor(Math.random() * 365);
                    const purchaseDate = new Date();
                    purchaseDate.setDate(purchaseDate.getDate() - daysAgo);
                    
                    purchases.push({
                        amount: amount,
                        product: product,
                        category: category,
                        date: purchaseDate.toISOString().split('T')[0]
                    });
                }
                
                const totalSpent = purchases.reduce((sum, p) => sum + p.amount, 0);
                const avgOrderValue = Math.round(totalSpent / purchases.length);
                const latestPurchase = new Date(Math.max(...purchases.map(p => new Date(p.date))));
                const daysSinceLastPurchase = Math.floor((new Date() - latestPurchase) / (1000 * 60 * 60 * 24));
                
                const categorySet = new Set(purchases.map(p => p.category));
                const categoryCount = {};
                purchases.forEach(p => {
                    categoryCount[p.category] = (categoryCount[p.category] || 0) + 1;
                });
                const favoriteCategory = Object.keys(categoryCount).reduce((a, b) => 
                    categoryCount[a] > categoryCount[b] ? a : b);
                
                customerData.push({
                    id: i,
                    name: `${surname}${givenName}`,
                    age: age,
                    totalSpent: totalSpent,
                    purchaseCount: purchases.length,
                    avgOrderValue: avgOrderValue,
                    daysSinceLastPurchase: daysSinceLastPurchase,
                    lastPurchaseDate: latestPurchase.toISOString().split('T')[0],
                    categoryDiversity: categorySet.size,
                    productDiversity: new Set(purchases.map(p => p.product)).size,
                    favoriteCategory: favoriteCategory,
                    avgPurchaseInterval: Math.round(365 / purchases.length),
                    recencyScore: 0,
                    frequencyScore: 0,
                    monetaryScore: 0,
                    cluster: null,
                    purchases: purchases
                });
            }
            
            calculateRFMScores(customerData);
            updateStats();
            updateTable();
            runClustering();
        }
        
        function euclideanDistance(point1, point2) {
            return Math.sqrt(
                point1.reduce((sum, val, index) => sum + Math.pow(val - point2[index], 2), 0)
            );
        }
        
        // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÌäπÏÑ± Î∂ÑÏÑù (ÏßÑÏßú AI Î∂ÑÏÑù)
        async function analyzeClusterCharacteristics() {
            const clusters = [...new Set(customerData.map(c => c.cluster))].filter(c => c !== null);
            
            document.getElementById('aiAnalysis').style.display = 'block';
            document.getElementById('clusterAnalysis').innerHTML = '<div class="loading">ü§ñ AIÍ∞Ä Í∞Å ÌÅ¥Îü¨Ïä§ÌÑ∞Î•º Ïã¨Ï∏µ Î∂ÑÏÑù Ï§ëÏûÖÎãàÎã§...<br>Ïã§Ï†ú Íµ¨Îß§ Ìå®ÌÑ¥Í≥º ÌñâÎèô Îç∞Ïù¥ÌÑ∞Î•º Ï¢ÖÌï©ÌïòÏó¨ Ïù∏ÏÇ¨Ïù¥Ìä∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.</div>';
            
            let analysisHTML = '<div class="cluster-cards">';
            
            for (const clusterId of clusters) {
                const clusterData = customerData.filter(c => c.cluster === clusterId);
                const count = clusterData.length;
                const percentage = Math.round(count/customerData.length*100);
                
                const clusterStats = {
                    clusterId: clusterId + 1,
                    count,
                    percentage
                };
                
                // Ïã§Ï†ú AI Î∂ÑÏÑù Ìò∏Ï∂ú
                const analysis = await analyzeClusterWithAI(clusterData, clusterStats);
                
                // ÌÅ¥Îü¨Ïä§ÌÑ∞ Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞
                const avgAge = Math.round(clusterData.reduce((sum, c) => sum + c.age, 0) / count);
                const avgSpent = Math.round(clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / count);
                const avgPurchases = Math.round(clusterData.reduce((sum, c) => sum + c.purchaseCount, 0) / count * 10) / 10;
                const avgOrderValue = Math.round(clusterData.reduce((sum, c) => sum + c.avgOrderValue, 0) / count);
                
                analysisHTML += `
                    <div class="cluster-card cluster-${clusterId}">
                        <div class="cluster-title">ÌÅ¥Îü¨Ïä§ÌÑ∞ ${clusterId + 1}: ${analysis.name}</div>
                        <div class="cluster-subtitle">Í≥†Í∞ù ${count}Î™Ö (${percentage}%)</div>
                        
                        <div class="cluster-metrics">
                            <div class="metric">
                                <div class="metric-value">${avgAge}ÏÑ∏</div>
                                <div class="metric-label">ÌèâÍ∑† Ïó∞Î†π</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgSpent.toLocaleString()}Ïõê</div>
                                <div class="metric-label">ÌèâÍ∑† Íµ¨Îß§Ïï°</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgPurchases}Ìöå</div>
                                <div class="metric-label">ÌèâÍ∑† Íµ¨Îß§ÌöüÏàò</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgOrderValue.toLocaleString()}Ïõê</div>
                                <div class="metric-label">ÌèâÍ∑† Ï£ºÎ¨∏Í∞ÄÍ≤©</div>
                            </div>
                        </div>
                        
                        <div class="ai-insights">
                            <div class="insight-title">üß† AI Î∂ÑÏÑù Ïù∏ÏÇ¨Ïù¥Ìä∏</div>
                            <div class="insight-text">${analysis.insights}</div>
                        </div>
                        
                        <div class="ai-strategy">
                            <div class="strategy-title">üéØ Ï∂îÏ≤ú Ïï°ÏÖòÌîåÎûú</div>
                            <div>${analysis.strategy}</div>
                        </div>
                    </div>
                `;
            }
            
            analysisHTML += '</div>';
            document.getElementById('clusterAnalysis').innerHTML = analysisHTML;
        }
        
        // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        function updateStats() {
            const totalCustomers = customerData.length;
            const avgAge = Math.round(customerData.reduce((sum, c) => sum + c.age, 0) / totalCustomers);
            const avgSpent = Math.round(customerData.reduce((sum, c) => sum + c.totalSpent, 0) / totalCustomers);
            const avgPurchases = Math.round(customerData.reduce((sum, c) => sum + c.purchaseCount, 0) / totalCustomers * 10) / 10;
            
            const clusterCounts = {};
            customerData.forEach(c => {
                if (c.cluster !== null) {
                    clusterCounts[c.cluster] = (clusterCounts[c.cluster] || 0) + 1;
                }
            });
            
            const statsHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalCustomers}</div>
                    <div class="stat-label">Ï¥ù Í≥†Í∞ù Ïàò</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgAge}ÏÑ∏</div>
                    <div class="stat-label">ÌèâÍ∑† Ïó∞Î†π</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgSpent.toLocaleString()}Ïõê</div>
                    <div class="stat-label">ÌèâÍ∑† Íµ¨Îß§Ïï°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgPurchases}Ìöå</div>
                    <div class="stat-label">ÌèâÍ∑† Íµ¨Îß§ÌöüÏàò</div>
                </div>
                ${Object.keys(clusterCounts).map(cluster => `
                    <div class="stat-card">
                        <div class="stat-value">${clusterCounts[cluster]}</div>
                        <div class="stat-label">ÌÅ¥Îü¨Ïä§ÌÑ∞ ${parseInt(cluster) + 1}</div>
                    </div>
                `).join('')}
            `;
            
            document.getElementById('statsGrid').innerHTML = statsHTML;
        }
        
        // ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = customerData.slice(0, 50).map(customer => `
                <tr class="cluster-${customer.cluster || 0}">
                    <td>${customer.id}</td>
                    <td>${customer.name}</td>
                    <td>${customer.age}ÏÑ∏</td>
                    <td>${customer.totalSpent.toLocaleString()}Ïõê</td>
                    <td>${customer.purchaseCount}Ìöå</td>
                    <td>${customer.avgOrderValue.toLocaleString()}Ïõê</td>
                    <td>${customer.favoriteCategory || '-'}</td>
                    <td>R${customer.recencyScore || 0}F${customer.frequencyScore || 0}M${customer.monetaryScore || 0}</td>
                    <td>${customer.cluster !== null ? `ÌÅ¥Îü¨Ïä§ÌÑ∞ ${customer.cluster + 1}` : '-'}</td>
                </tr>
            `).join('');
        }
        
        // Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        function updateCharts() {
            const colors = ['#FF6B6B', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'];
            
            const scatterData = {
                datasets: []
            };
            
            const clusters = [...new Set(customerData.map(c => c.cluster))].filter(c => c !== null);
            clusters.forEach(cluster => {
                const clusterData = customerData.filter(c => c.cluster === cluster);
                scatterData.datasets.push({
                    label: `ÌÅ¥Îü¨Ïä§ÌÑ∞ ${cluster + 1}`,
                    data: clusterData.map(c => ({ x: c.age, y: c.totalSpent })),
                    backgroundColor: colors[cluster],
                    borderColor: colors[cluster],
                    pointBorderWidth: 2,
                    pointRadius: 4
                });
            });
            
            if (scatterChart) scatterChart.destroy();
            scatterChart = new Chart(document.getElementById('scatterChart'), {
                type: 'scatter',
                data: scatterData,
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Ïó∞Î†πÎ≥Ñ Ï¥ù Íµ¨Îß§Í∏àÏï° Î∂ÑÌè¨'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Ïó∞Î†π'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Ï¥ù Íµ¨Îß§Í∏àÏï° (Ïõê)'
                            }
                        }
                    }
                }
            });
            
            const clusterAvgs = {};
            clusters.forEach(cluster => {
                const clusterData = customerData.filter(c => c.cluster === cluster);
                clusterAvgs[cluster] = clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / clusterData.length;
            });
            
            if (barChart) barChart.destroy();
            barChart = new Chart(document.getElementById('barChart'), {
                type: 'bar',
                data: {
                    labels: clusters.map(c => `ÌÅ¥Îü¨Ïä§ÌÑ∞ ${c + 1}`),
                    datasets: [{
                        label: 'ÌèâÍ∑† Íµ¨Îß§Í∏àÏï°',
                        data: clusters.map(c => clusterAvgs[c]),
                        backgroundColor: clusters.map(c => colors[c]),
                        borderColor: clusters.map(c => colors[c]),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'ÌÅ¥Îü¨Ïä§ÌÑ∞Î≥Ñ ÌèâÍ∑† Íµ¨Îß§Í∏àÏï°'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ÌèâÍ∑† Íµ¨Îß§Í∏àÏï° (Ïõê)'
                            }
                        }
                    }
                }
            });
        }
        
        // CSV Îã§Ïö¥Î°úÎìú
        function downloadCSV() {
            const headers = ['Í≥†Í∞ùID', 'Ïù¥Î¶Ñ', 'Ïó∞Î†π', 'Ï¥ùÍµ¨Îß§Í∏àÏï°', 'Íµ¨Îß§ÌöüÏàò', 'ÌèâÍ∑†Ï£ºÎ¨∏Í∞ÄÍ≤©', 'ÏÑ†Ìò∏Ïπ¥ÌÖåÍ≥†Î¶¨', 'RFMÏ†êÏàò', 'ÌÅ¥Îü¨Ïä§ÌÑ∞'];
            const csvContent = [
                headers.join(','),
                ...customerData.map(customer => [
                    customer.id,
                    customer.name,
                    customer.age,
                    customer.totalSpent,
                    customer.purchaseCount,
                    customer.avgOrderValue,
                    customer.favoriteCategory || '',
                    `R${customer.recencyScore}F${customer.frequencyScore}M${customer.monetaryScore}`,
                    customer.cluster !== null ? customer.cluster + 1 : ''
                ].join(','))
            ].join('\n');
            
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'ai_customer_clustering_results.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // CSV ÌÖúÌîåÎ¶ø Îã§Ïö¥Î°úÎìú
        function downloadTemplate() {
            const templateData = [
                ['Í≥†Í∞ùID', 'Ïù¥Î¶Ñ', 'Ïó∞Î†π', '1ÌöåÍµ¨Îß§Í∞ÄÍ≤©', 'Íµ¨Îß§ÏÉÅÌíà', 'Ïπ¥ÌÖåÍ≥†Î¶¨', 'Íµ¨Îß§Ïùº'].join(','),
                [1, 'ÍπÄÎØºÏàò', 35, 50000, 'ÎãπÍ∑º', 'Ï±ÑÏÜå', '2024-05-15'].join(','),
                [1, 'ÍπÄÎØºÏàò', 35, 500000, 'ÏãúÍ∏àÏπò', 'Ï±ÑÏÜå', '2024-05-15'].join(','),
                [2, 'Ïù¥ÏòÅÌù¨', 28, 350000, 'ÍπÄÎ∞•', 'Ï¶âÏÑùÏãùÌíà', '2024-05-20'].join(','),
                [3, 'Î∞ïÏ≤†Ïàò', 42, 750000, 'Îã≠Í∞ÄÏä¥ÏÇ¥', 'Ïú°Î•ò', '2024-05-10'].join(','),
                [3, 'Î∞ïÏ≤†Ïàò', 42, 750000, 'ÏÉ§Î∏åÏÉ§Î∏åÏö© ÎÉâÎèô Î™©
