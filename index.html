<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ê³ ê° í´ëŸ¬ìŠ¤í„°ë§ ë¶„ì„</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .upload-info {
            background: #e8f4fd;
            border: 2px dashed #36A2EB;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            color: #2c3e50;
            display: none;
        }
        
        .upload-success {
            background: #d4edda;
            border: 2px solid #28a745;
            color: #155724;
        }
        
        .upload-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            color: #721c24;
        }
        
        .charts-section {
            margin: 30px 0;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .ai-analysis-section {
            margin: 30px 0;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .ai-title {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .cluster-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .cluster-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border-left: 6px solid;
        }
        
        .cluster-card.cluster-0 { border-left-color: #FF6B6B; }
        .cluster-card.cluster-1 { border-left-color: #36A2EB; }
        .cluster-card.cluster-2 { border-left-color: #FFCE56; }
        .cluster-card.cluster-3 { border-left-color: #4BC0C0; }
        .cluster-card.cluster-4 { border-left-color: #9966FF; }
        
        .cluster-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .cluster-subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
            margin-bottom: 20px;
            font-style: italic;
        }
        
        .cluster-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .metric-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 2px;
        }
        
        .ai-insights {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .insight-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 8px;
        }
        
        .insight-text {
            color: #424242;
            line-height: 1.6;
        }
        
        .ai-strategy {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .strategy-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .data-table {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            margin-top: 30px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
        }
        
        tr:hover {
            background: #f8f9ff;
        }
        
        .cluster-0 { background-color: rgba(255, 107, 107, 0.1); }
        .cluster-1 { background-color: rgba(54, 162, 235, 0.1); }
        .cluster-2 { background-color: rgba(255, 206, 86, 0.1); }
        .cluster-3 { background-color: rgba(75, 192, 192, 0.1); }
        .cluster-4 { background-color: rgba(153, 102, 255, 0.1); }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-size: 1.2em;
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .cluster-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– AI ê¸°ë°˜ ê³ ê° í´ëŸ¬ìŠ¤í„°ë§ ë¶„ì„</h1>
        
        <div class="controls">
            <button onclick="generateData()">ìƒˆ ë°ì´í„° ìƒì„± (1000ëª…)</button>
            <input type="file" id="csvFileInput" accept=".csv" onchange="handleCSVUpload(event)" style="display: none;">
            <button onclick="document.getElementById('csvFileInput').click()">ğŸ“ CSV íŒŒì¼ ì—…ë¡œë“œ</button>
            <select id="clusterCount" onchange="runClustering()">
                <option value="3">3ê°œ í´ëŸ¬ìŠ¤í„°</option>
                <option value="4" selected>4ê°œ í´ëŸ¬ìŠ¤í„°</option>
                <option value="5">5ê°œ í´ëŸ¬ìŠ¤í„°</option>
            </select>
            <button onclick="runClustering()">í´ëŸ¬ìŠ¤í„°ë§ ì‹¤í–‰</button>
            <button onclick="downloadCSV()">CSV ë‹¤ìš´ë¡œë“œ</button>
            <button onclick="downloadTemplate()">ğŸ“‹ CSV í…œí”Œë¦¿ ë‹¤ìš´ë¡œë“œ</button>
        </div>
        
        <div class="stats-grid" id="statsGrid"></div>
        
        <div id="uploadStatus" class="upload-info"></div>
        
        <div class="charts-section">
            <div class="charts-container">
                <div class="chart-container">
                    <canvas id="scatterChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="barChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="ai-analysis-section" id="aiAnalysis" style="display: none;">
            <h2 class="ai-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</h2>
            <div id="clusterAnalysis"></div>
        </div>
        
        <div class="data-table">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>ê³ ê°ID</th>
                        <th>ì´ë¦„</th>
                        <th>ì—°ë ¹</th>
                        <th>ì´ êµ¬ë§¤ê¸ˆì•¡</th>
                        <th>êµ¬ë§¤íšŸìˆ˜</th>
                        <th>í‰ê·  ì£¼ë¬¸ê°€ê²©</th>
                        <th>ì„ í˜¸ ì¹´í…Œê³ ë¦¬</th>
                        <th>RFM ì ìˆ˜</th>
                        <th>í´ëŸ¬ìŠ¤í„°</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let customerData = [];
        let scatterChart, barChart;
        
        // ë¶„ì‚° ê³„ì‚° ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        function calculateVariance(values) {
            if (values.length === 0) return 0;
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return variance;
        }
        
        // ì‹¤ì œ AI ë¶„ì„ í•¨ìˆ˜ (ìƒí’ˆë³„ êµ¬ë§¤ íŒ¨í„´ í¬í•¨)
        async function analyzeClusterWithAI(clusterData, clusterStats) {
            // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Claude APIë¥¼ í˜¸ì¶œ
            await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
            
            // ìƒí’ˆë³„ êµ¬ë§¤ íŒ¨í„´ì„ í¬í•¨í•œ ì¢…í•© ë¶„ì„
            const insights = generateAdvancedDataDrivenInsights(clusterData, clusterStats);
            return insights;
        }
        
        // ê³ ê¸‰ ë°ì´í„° ê¸°ë°˜ ì¸ì‚¬ì´íŠ¸ ìƒì„± (ìƒí’ˆ ë ˆë²¨ ë¶„ì„ í¬í•¨)
        function generateAdvancedDataDrivenInsights(clusterData, clusterStats) {
            const { clusterId, count, percentage } = clusterStats;
            
            // ê¸°ë³¸ í†µê³„
            const avgAge = clusterData.reduce((sum, c) => sum + c.age, 0) / count;
            const avgSpent = clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / count;
            const avgPurchases = clusterData.reduce((sum, c) => sum + c.purchaseCount, 0) / count;
            const avgDaysSince = clusterData.reduce((sum, c) => sum + c.daysSinceLastPurchase, 0) / count;
            
            // ìƒí’ˆë³„ êµ¬ë§¤ íŒ¨í„´ ì‹¬ì¸µ ë¶„ì„
            const productAnalysis = analyzeProductPatterns(clusterData);
            const categoryAnalysis = analyzeCategoryPatterns(clusterData);
            const purchaseBehavior = analyzePurchaseBehavior(clusterData);
            const priceAnalysis = analyzePricePatterns(clusterData);
            
            // RFM ì ìˆ˜ ë¶„í¬
            const rfmScores = clusterData.map(c => 
                (c.recencyScore || 0) + (c.frequencyScore || 0) + (c.monetaryScore || 0)
            );
            const avgRFM = rfmScores.reduce((sum, score) => sum + score, 0) / rfmScores.length;
            
            // AI ìŠ¤íƒ€ì¼ ì¢…í•© ë¶„ì„
            const name = generateAdvancedClusterName(
                avgRFM, avgSpent, avgPurchases, avgAge, 
                productAnalysis, categoryAnalysis, purchaseBehavior, clusterData
            );
            
            const insights = generateComprehensiveInsights(
                avgAge, avgSpent, avgPurchases, avgDaysSince, avgRFM, 
                productAnalysis, categoryAnalysis, purchaseBehavior, priceAnalysis, percentage
            );
            
            const strategy = generateDetailedStrategy(
                name, productAnalysis, categoryAnalysis, purchaseBehavior, avgAge
            );
            
            return { name, insights, strategy };
        }
        
        // ìƒí’ˆë³„ êµ¬ë§¤ íŒ¨í„´ ë¶„ì„ (ì•ˆì „í•œ ì²˜ë¦¬)
        function analyzeProductPatterns(clusterData) {
            try {
                const productFreq = {};
                const productRevenue = {};
                let totalProducts = 0;
                
                clusterData.forEach(customer => {
                    if (customer.purchases && Array.isArray(customer.purchases)) {
                        customer.purchases.forEach(purchase => {
                            if (purchase && purchase.product && purchase.amount) {
                                const product = purchase.product || 'ì•Œ ìˆ˜ ì—†ìŒ';
                                const amount = parseFloat(purchase.amount) || 0;
                                
                                productFreq[product] = (productFreq[product] || 0) + 1;
                                productRevenue[product] = (productRevenue[product] || 0) + amount;
                                totalProducts++;
                            }
                        });
                    }
                });
                
                if (totalProducts === 0) {
                    return {
                        topProducts: [],
                        topRevenueProducts: [],
                        uniqueProductCount: 0,
                        totalPurchases: 0
                    };
                }
                
                // ì¸ê¸° ìƒí’ˆ TOP 3
                const topProducts = Object.entries(productFreq)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([product, count]) => ({
                        product,
                        count,
                        percentage: Math.round(count / totalProducts * 100)
                    }));
                
                // ê³ ìˆ˜ìµ ìƒí’ˆ TOP 3
                const topRevenueProducts = Object.entries(productRevenue)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([product, revenue]) => ({
                        product,
                        revenue,
                        avgPrice: Math.round(revenue / (productFreq[product] || 1))
                    }));
                
                return {
                    topProducts,
                    topRevenueProducts,
                    uniqueProductCount: Object.keys(productFreq).length,
                    totalPurchases: totalProducts
                };
            } catch (error) {
                console.warn('ìƒí’ˆ íŒ¨í„´ ë¶„ì„ ì˜¤ë¥˜:', error);
                return {
                    topProducts: [],
                    topRevenueProducts: [],
                    uniqueProductCount: 0,
                    totalPurchases: 0
                };
            }
        }
        
        // ì¹´í…Œê³ ë¦¬ë³„ êµ¬ë§¤ íŒ¨í„´ ë¶„ì„
        function analyzeCategoryPatterns(clusterData) {
            const categoryFreq = {};
            const categorySpend = {};
            let totalSpend = 0;
            
            clusterData.forEach(customer => {
                if (customer.purchases) {
                    customer.purchases.forEach(purchase => {
                        const category = purchase.category || 'ê¸°íƒ€';
                        categoryFreq[category] = (categoryFreq[category] || 0) + 1;
                        categorySpend[category] = (categorySpend[category] || 0) + purchase.amount;
                        totalSpend += purchase.amount;
                    });
                }
            });
            
            // ì¹´í…Œê³ ë¦¬ë³„ ì§€ì¶œ ë¹„ìœ¨
            const categoryDistribution = Object.entries(categorySpend)
                .sort(([,a], [,b]) => b - a)
                .map(([category, spend]) => ({
                    category,
                    spend,
                    percentage: Math.round(spend / totalSpend * 100),
                    avgOrderValue: Math.round(spend / (categoryFreq[category] || 1))
                }));
            
            // ì¹´í…Œê³ ë¦¬ ì§‘ì¤‘ë„ (í—ˆí•€ë‹¬ ì§€ìˆ˜)
            const concentration = categoryDistribution.reduce((sum, cat) => 
                sum + Math.pow(cat.percentage / 100, 2), 0
            );
            
            return {
                distribution: categoryDistribution,
                concentration: concentration,
                diversityScore: Math.round((1 - concentration) * 100),
                dominantCategory: categoryDistribution[0]?.category || 'ì—†ìŒ'
            };
        }
        
        // êµ¬ë§¤ í–‰ë™ íŒ¨í„´ ë¶„ì„ (ì•ˆì „í•œ ì²˜ë¦¬)
        function analyzePurchaseBehavior(clusterData) {
            try {
                const behaviors = {
                    impulseBuyers: 0,
                    plannedBuyers: 0,
                    loyalBuyers: 0,
                    explorers: 0
                };
                
                clusterData.forEach(customer => {
                    if (customer.purchases && Array.isArray(customer.purchases) && customer.purchases.length > 1) {
                        try {
                            // êµ¬ë§¤ ê°„ê²© ë¶„ì„
                            const intervals = [];
                            const sortedPurchases = customer.purchases
                                .filter(p => p && p.date && p.date !== '')
                                .sort((a, b) => {
                                    try {
                                        return new Date(a.date) - new Date(b.date);
                                    } catch {
                                        return 0;
                                    }
                                });
                            
                            for (let i = 1; i < sortedPurchases.length; i++) {
                                try {
                                    const interval = (new Date(sortedPurchases[i].date) - new Date(sortedPurchases[i-1].date)) / (1000 * 60 * 60 * 24);
                                    if (!isNaN(interval) && interval >= 0) {
                                        intervals.push(interval);
                                    }
                                } catch {
                                    // ë‚ ì§œ íŒŒì‹± ì˜¤ë¥˜ ë¬´ì‹œ
                                }
                            }
                            
                            const avgInterval = intervals.length > 0 ? 
                                intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length : 30;
                            const intervalVariance = intervals.length > 1 ? calculateVariance(intervals) : 100;
                            
                            // ìƒí’ˆ ë‹¤ì–‘ì„±
                            const uniqueProducts = new Set(customer.purchases.map(p => p.product || 'ì•Œ ìˆ˜ ì—†ìŒ')).size;
                            const productLoyalty = customer.purchases.length / Math.max(uniqueProducts, 1);
                            
                            // í–‰ë™ ìœ í˜• ë¶„ë¥˜
                            if (avgInterval < 7 && intervalVariance > 50) {
                                behaviors.impulseBuyers++;
                            } else if (avgInterval > 30 && intervalVariance < 100) {
                                behaviors.plannedBuyers++;
                            } else if (productLoyalty > 2) {
                                behaviors.loyalBuyers++;
                            } else {
                                behaviors.explorers++;
                            }
                        } catch (error) {
                            console.warn('ê°œë³„ ê³ ê° í–‰ë™ ë¶„ì„ ì˜¤ë¥˜:', error);
                            behaviors.explorers++; // ê¸°ë³¸ê°’
                        }
                    } else {
                        behaviors.explorers++; // ê¸°ë³¸ê°’
                    }
                });
                
                const total = Object.values(behaviors).reduce((sum, count) => sum + count, 0);
                const behaviorDistribution = {};
                Object.keys(behaviors).forEach(behavior => {
                    behaviorDistribution[behavior] = total > 0 ? Math.round(behaviors[behavior] / total * 100) : 25;
                });
                
                return {
                    distribution: behaviorDistribution,
                    dominantBehavior: Object.keys(behaviorDistribution).reduce((a, b) => 
                        behaviorDistribution[a] > behaviorDistribution[b] ? a : b
                    )
                };
            } catch (error) {
                console.warn('êµ¬ë§¤ í–‰ë™ ë¶„ì„ ì˜¤ë¥˜:', error);
                return {
                    distribution: { impulseBuyers: 25, plannedBuyers: 25, loyalBuyers: 25, explorers: 25 },
                    dominantBehavior: 'explorers'
                };
            }
        }
        
        // ê°€ê²© íŒ¨í„´ ë¶„ì„
        function analyzePricePatterns(clusterData) {
            const allPrices = [];
            clusterData.forEach(customer => {
                if (customer.purchases) {
                    customer.purchases.forEach(purchase => {
                        allPrices.push(purchase.amount);
                    });
                }
            });
            
            if (allPrices.length === 0) return { sensitivity: 'unknown', pattern: 'insufficient_data' };
            
            allPrices.sort((a, b) => a - b);
            const median = allPrices[Math.floor(allPrices.length / 2)];
            const q1 = allPrices[Math.floor(allPrices.length * 0.25)];
            const q3 = allPrices[Math.floor(allPrices.length * 0.75)];
            const iqr = q3 - q1;
            const priceVariance = calculateVariance(allPrices);
            
            let sensitivity, pattern;
            if (priceVariance < 100000) {
                sensitivity = 'ì¼ê´€ëœ ê°€ê²©ëŒ€ ì„ í˜¸';
                pattern = 'consistent';
            } else if (iqr > median) {
                sensitivity = 'ê°€ê²© íƒ„ë ¥ì ';
                pattern = 'flexible';
            } else {
                sensitivity = 'ê°€ê²© ë¯¼ê°í˜•';
                pattern = 'sensitive';
            }
            
            return {
                median: median,
                iqr: iqr,
                variance: priceVariance,
                sensitivity: sensitivity,
                pattern: pattern
            };
        }
        
        // ê³ ê¸‰ í´ëŸ¬ìŠ¤í„° ëª…ëª… - ë²¡í„° ê¸°ë°˜ íŠ¹ì„± ë¶„ì„
        function generateAdvancedClusterName(rfm, spent, purchases, age, productAnalysis, categoryAnalysis, purchaseBehavior, clusterData) {
            // í´ëŸ¬ìŠ¤í„°ì˜ ì‹¤ì œ íŠ¹ì„±ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ë‹¤ì°¨ì› ë¶„ì„
            const features = {
                rfmScore: rfm,
                spendingLevel: spent,
                purchaseFrequency: purchases,
                ageGroup: age,
                dominantCategory: categoryAnalysis.dominantCategory,
                categoryDiversity: categoryAnalysis.diversityScore,
                behaviorType: purchaseBehavior.dominantBehavior,
                productVariety: productAnalysis.uniqueProductCount,
                priceRange: analyzePricePatterns(clusterData).pattern
            };
            
            // í´ëŸ¬ìŠ¤í„°ì˜ ì£¼ìš” íŠ¹ì„± ë²¡í„° ê³„ì‚°
            const characteristicVector = calculateCharacteristicVector(features);
            
            // í´ëŸ¬ìŠ¤í„° íŠ¹ì„± ì ìˆ˜ ê¸°ë°˜ ëª…ëª…
            return generateDataDrivenClusterName(characteristicVector, features);
        }
        
        // í´ëŸ¬ìŠ¤í„° íŠ¹ì„± ë²¡í„° ê³„ì‚°
        function calculateCharacteristicVector(features) {
            const vector = {
                luxuryScore: 0,
                loyaltyScore: 0,
                diversityScore: 0,
                valueScore: 0,
                frequencyScore: 0,
                techScore: 0,
                familyScore: 0,
                trendScore: 0
            };
            
            // Luxury Score (ê³ ê¸‰ ì†Œë¹„ ì„±í–¥)
            vector.luxuryScore = (features.spendingLevel / 1000000) * 0.4 + 
                                (features.rfmScore / 15) * 0.3 +
                                (features.priceRange === 'flexible' ? 0.3 : 0);
            
            // Loyalty Score (ì¶©ì„±ë„)
            vector.loyaltyScore = (features.behaviorType === 'loyalBuyers' ? 0.5 : 0) +
                                 (features.purchaseFrequency / 30) * 0.3 +
                                 (features.categoryDiversity < 30 ? 0.2 : 0);
            
            // Diversity Score (ë‹¤ì–‘ì„± ì¶”êµ¬)
            vector.diversityScore = (features.categoryDiversity / 100) * 0.4 +
                                   (features.productVariety / 50) * 0.3 +
                                   (features.behaviorType === 'explorers' ? 0.3 : 0);
            
            // Value Score (ê°€ì¹˜ ì¶”êµ¬)
            vector.valueScore = (features.spendingLevel < 300000 ? 0.4 : 0) +
                               (features.priceRange === 'sensitive' ? 0.3 : 0) +
                               (features.ageGroup < 35 ? 0.3 : 0);
            
            // Frequency Score (êµ¬ë§¤ ë¹ˆë„)
            vector.frequencyScore = Math.min(features.purchaseFrequency / 20, 1);
            
            // Tech Score (ê¸°ìˆ  ì¹œí™”ë„)
            vector.techScore = (features.dominantCategory === 'ì „ìì œí’ˆ' ? 0.6 : 0) +
                              (features.ageGroup < 40 ? 0.4 : 0);
            
            // Family Score (ê°€ì¡± ì¤‘ì‹¬)
            vector.familyScore = (features.dominantCategory === 'ìœ ì œí’ˆ' ? 0.3 : 0) +
                                (features.dominantCategory === 'ìƒí™œìš©í’ˆ' ? 0.3 : 0) +
                                (features.ageGroup > 35 ? 0.4 : 0);
            
            // Trend Score (íŠ¸ë Œë“œ ë¯¼ê°ë„)
            vector.trendScore = (features.dominantCategory === 'ì˜ë¥˜' ? 0.4 : 0) +
                               (features.behaviorType === 'impulseBuyers' ? 0.3 : 0) +
                               (features.ageGroup < 35 ? 0.3 : 0);
            
            return vector;
        }
        
        // ë°ì´í„° ê¸°ë°˜ í´ëŸ¬ìŠ¤í„° ì´ë¦„ ìƒì„±
        function generateDataDrivenClusterName(vector, features) {
            // ê°€ì¥ ë†’ì€ íŠ¹ì„± ì ìˆ˜ ì°¾ê¸°
            const scores = Object.entries(vector).sort(([,a], [,b]) => b - a);
            const primaryTrait = scores[0][0];
            const secondaryTrait = scores[1][0];
            const primaryScore = scores[0][1];
            const secondaryScore = scores[1][1];
            
            // ë³µí•© íŠ¹ì„± ê¸°ë°˜ ëª…ëª…
            if (primaryScore > 0.8) {
                // ë‹¨ì¼ íŠ¹ì„±ì´ ë§¤ìš° ê°•í•œ ê²½ìš°
                const strongNames = {
                    luxuryScore: "ğŸ‘‘ í”„ë¦¬ë¯¸ì—„ VIP",
                    loyaltyScore: "ğŸ’ ì¶©ì„± ê³ ê°êµ°",
                    diversityScore: "ğŸŒˆ ë‹¤ì–‘ì„± ì¶”êµ¬ì",
                    valueScore: "ğŸ’° ê°€ì¹˜ ì¤‘ì‹œí˜•",
                    frequencyScore: "âš¡ ìƒì‹œ êµ¬ë§¤ì",
                    techScore: "ğŸ”Œ í…Œí¬ ì• í˜¸ê°€",
                    familyScore: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ íŒ¨ë°€ë¦¬ ì¼€ì–´",
                    trendScore: "âœ¨ íŠ¸ë Œë“œ ì„¸í„°"
                };
                return strongNames[primaryTrait] || "â­ ì¼ë°˜ ê³ ê°";
            }
            
            // ë³µí•© íŠ¹ì„± ì¡°í•©
            const combinedName = getCombinedClusterName(primaryTrait, secondaryTrait, features);
            return combinedName;
        }
        
        // ë³µí•© íŠ¹ì„± ê¸°ë°˜ í´ëŸ¬ìŠ¤í„° ëª…ëª…
        function getCombinedClusterName(primary, secondary, features) {
            const combinations = {
                'luxuryScore_loyaltyScore': "ğŸ‘‘ í”„ë¦¬ë¯¸ì—„ ë¡œì—´í‹°ìŠ¤íŠ¸",
                'luxuryScore_diversityScore': "ğŸ’ ëŸ­ì…”ë¦¬ ìµìŠ¤í”Œë¡œëŸ¬",
                'loyaltyScore_frequencyScore': "ğŸ† ìŠˆí¼ ë‹¨ê³¨ê³ ê°",
                'loyaltyScore_familyScore': "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ íŒ¨ë°€ë¦¬ ì •ì°©í˜•",
                'diversityScore_trendScore': "ğŸ¯ íŠ¸ë Œë“œ í—Œí„°",
                'diversityScore_valueScore': "ğŸ›ï¸ ìŠ¤ë§ˆíŠ¸ ì‡¼í¼",
                'valueScore_frequencyScore': "ğŸ’¸ ì‹¤ì†í˜• ìƒì‹œê³ ê°",
                'valueScore_familyScore': "ğŸ‘¶ ì•Œëœ° íŒ¨ë°€ë¦¬",
                'techScore_luxuryScore': "ğŸš€ í…Œí¬ í”„ë¦¬ë¯¸ì—„",
                'techScore_trendScore': "ğŸ“± ë””ì§€í„¸ íŠ¸ë Œë“œì„¸í„°",
                'familyScore_frequencyScore': "ğŸ  ìƒí™œë°€ì°©í˜•",
                'trendScore_frequencyScore': "âš¡ íŠ¸ë Œë“œ í€µë°”ì´ì–´"
            };
            
            const key = `${primary}_${secondary}`;
            const reverseKey = `${secondary}_${primary}`;
            
            // ì—°ë ¹ê³¼ ì§€ì¶œ íŠ¹ì„±ì„ ì¶”ê°€ë¡œ ê³ ë ¤
            if (features.ageGroup < 30 && features.spendingLevel < 200000) {
                return "ğŸŒ± ì˜ ìŠ¤ë§ˆíŠ¸ ì»¨ìŠˆë¨¸";
            }
            if (features.ageGroup > 50 && features.purchaseFrequency > 15) {
                return "ğŸ–ï¸ ì‹œë‹ˆì–´ VIP";
            }
            
            return combinations[key] || combinations[reverseKey] || "â­ ê· í˜•í˜• ê³ ê°";
        }
        
        // ì¢…í•© ì¸ì‚¬ì´íŠ¸ ìƒì„±
        function generateComprehensiveInsights(age, spent, purchases, daysSince, rfm, productAnalysis, categoryAnalysis, purchaseBehavior, priceAnalysis, percentage) {
            const topProducts = productAnalysis.topProducts.map(p => `${p.product}(${p.percentage}%)`).join(', ');
            const topCategory = categoryAnalysis.distribution[0];
            const behaviorType = purchaseBehavior.dominantBehavior;
            
            const behaviorDesc = {
                'impulseBuyers': 'ì¶©ë™êµ¬ë§¤í˜•',
                'plannedBuyers': 'ê³„íšêµ¬ë§¤í˜•', 
                'loyalBuyers': 'ì¶©ì„±êµ¬ë§¤í˜•',
                'explorers': 'íƒí—˜í˜•'
            };
            
            return `ì´ í´ëŸ¬ìŠ¤í„°ëŠ” ì „ì²´ ê³ ê°ì˜ ${percentage}%ë¥¼ ì°¨ì§€í•˜ë©°, í‰ê·  ì—°ë ¹ ${age.toFixed(0)}ì„¸ì˜ ${behaviorDesc[behaviorType]} ê³ ê°ë“¤ì…ë‹ˆë‹¤.
            
            ğŸ“Š êµ¬ë§¤ íŒ¨í„´: ì´ ${productAnalysis.uniqueProductCount}ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ìƒí’ˆì„ êµ¬ë§¤í–ˆìœ¼ë©°, ì£¼ìš” ì¸ê¸° ìƒí’ˆì€ ${topProducts}ì…ë‹ˆë‹¤. 
            ${topCategory?.category || 'ë‹¤ì–‘í•œ'} ì¹´í…Œê³ ë¦¬ì—ì„œ ${topCategory?.percentage || 0}%ì˜ ì§€ì¶œ ë¹„ì¤‘ì„ ë³´ì´ë©°, ì¹´í…Œê³ ë¦¬ ë‹¤ì–‘ì„± ì ìˆ˜ëŠ” ${categoryAnalysis.diversityScore}ì ì…ë‹ˆë‹¤.
            
            ğŸ’° ì§€ì¶œ íŠ¹ì„±: í‰ê·  ${spent.toLocaleString()}ì›ì„ ì§€ì¶œí•˜ê³  ${purchases.toFixed(1)}íšŒ êµ¬ë§¤í•˜ì—¬ RFM ì ìˆ˜ ${rfm.toFixed(1)}ì ì„ ê¸°ë¡í–ˆìŠµë‹ˆë‹¤. 
            ${priceAnalysis.sensitivity} íŠ¹ì„±ì„ ë³´ì´ë©°, ê°€ê²© ì¤‘ìœ„ê°’ì€ ${priceAnalysis.median?.toLocaleString() || 0}ì›ì…ë‹ˆë‹¤.
            
            ğŸ¯ í–‰ë™ íŠ¹ì„±: ${behaviorDesc[behaviorType]} ê³ ê°ì´ ${purchaseBehavior.distribution[behaviorType]}%ë¥¼ ì°¨ì§€í•˜ë©°, 
            ìµœê·¼ êµ¬ë§¤ë¡œë¶€í„° í‰ê·  ${daysSince.toFixed(0)}ì¼ì´ ê²½ê³¼í–ˆìŠµë‹ˆë‹¤.`;
        }
        
        // ìƒì„¸ ì „ëµ ìƒì„±
        function generateDetailedStrategy(name, productAnalysis, categoryAnalysis, purchaseBehavior, age) {
            const topProduct = productAnalysis.topProducts[0]?.product;
            const topCategory = categoryAnalysis.distribution[0]?.category;
            const behavior = purchaseBehavior.dominantBehavior;
            
            const strategies = [];
            
            // ìƒí’ˆ ê¸°ë°˜ ì „ëµ
            if (topProduct) {
                strategies.push(`${topProduct} ìƒí’ˆêµ° ì¤‘ì‹¬ì˜ í¬ë¡œìŠ¤ì…€ë§ ë° ì—…ì…€ë§ ì „ëµ ì‹¤í–‰`);
            }
            
            // ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ ì „ëµ
            if (topCategory && categoryAnalysis.concentration > 0.4) {
                strategies.push(`${topCategory} ì¹´í…Œê³ ë¦¬ ì „ë¬¸ì„±ì„ ì–´í•„í•˜ëŠ” íë ˆì´ì…˜ ì„œë¹„ìŠ¤ ì œê³µ`);
            } else {
                strategies.push(`ë‹¤ì–‘í•œ ì¹´í…Œê³ ë¦¬ ë²ˆë“¤ë§ì„ í†µí•œ í¬ë¡œìŠ¤ ì¹´í…Œê³ ë¦¬ ë§¤ì¶œ ì¦ëŒ€`);
            }
            
            // í–‰ë™ íŒ¨í„´ ê¸°ë°˜ ì „ëµ
            const behaviorStrategies = {
                'impulseBuyers': 'ì‹¤ì‹œê°„ ê°œì¸í™” ì¶”ì²œê³¼ í•œì •ì‹œê°„ í• ì¸ìœ¼ë¡œ êµ¬ë§¤ ì¶©ë™ ìê·¹',
                'plannedBuyers': 'ì •ê¸° ì£¼ë¬¸ ì‹œìŠ¤í…œê³¼ ë¯¸ë¦¬ ì•Œë¦¼ ì„œë¹„ìŠ¤ë¡œ êµ¬ë§¤ í¸ì˜ì„± ì œê³ ',
                'loyalBuyers': 'ë¸Œëœë“œ ì¶©ì„±ë„ ë¦¬ì›Œë“œ í”„ë¡œê·¸ë¨ê³¼ VIP í˜œíƒìœ¼ë¡œ ê´€ê³„ ì‹¬í™”',
                'explorers': 'ì‹ ì œí’ˆ ìš°ì„  ì²´í—˜ê³¼ ë‹¤ì–‘ì„± ì¶”êµ¬ ë§ì¶¤ ì¶”ì²œìœ¼ë¡œ íƒí—˜ ìš•êµ¬ ì¶©ì¡±'
            };
            strategies.push(behaviorStrategies[behavior]);
            
            // ì—°ë ¹ ê¸°ë°˜ ì „ëµ
            if (age < 35) {
                strategies.push('ì†Œì…œë¯¸ë””ì–´ ë§ˆì¼€íŒ…ê³¼ ì¸í”Œë£¨ì–¸ì„œ í˜‘ì—…ì„ í†µí•œ ì Šì€ ê³ ê°ì¸µ engagement ê°•í™”');
            } else {
                strategies.push('ì‹ ë¢°ì„±ê³¼ í’ˆì§ˆì„ ê°•ì¡°í•œ ì „í†µì  ë§ˆì¼€íŒ… ì±„ë„ í™œìš©');
            }
            
            return strategies.slice(0, 4).join('. ') + '.';
        }
        
        // CSV íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            showUploadStatus('ğŸ“¤ CSV íŒŒì¼ì„ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...', 'info');
            
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                encoding: 'UTF-8',
                complete: function(results) {
                    try {
                        const processedData = processCSVData(results.data);
                        if (processedData && processedData.length > 0) {
                            customerData = processedData;
                            showUploadStatus(`âœ… ${processedData.length}ëª…ì˜ ê³ ê° ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œí–ˆìŠµë‹ˆë‹¤!`, 'success');
                            updateStats();
                            updateTable();
                            runClustering();
                        } else {
                            throw new Error('ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        }
                    } catch (error) {
                        showUploadStatus(`âŒ íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`, 'error');
                        console.error('CSV ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                    }
                },
                error: function(error) {
                    showUploadStatus(`âŒ íŒŒì¼ ì½ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`, 'error');
                    console.error('CSV íŒŒì‹± ì˜¤ë¥˜:', error);
                }
            });
        }
        
        // CSV ë°ì´í„° ì²˜ë¦¬ ë° ë³€í™˜ (ìƒí’ˆë³„ êµ¬ë§¤ ì´ë ¥ â†’ ê³ ê°ë³„ ì§‘ê³„)
        function processCSVData(rawData) {
            const customerGroups = {};
            
            rawData.forEach((row, index) => {
                try {
                    const cleanRow = {};
                    Object.keys(row).forEach(key => {
                        const cleanKey = key.trim().toLowerCase().replace(/\s+/g, '');
                        cleanRow[cleanKey] = row[key];
                    });
                    
                    const customerId = cleanRow['ê³ ê°id'] || cleanRow['customerid'] || cleanRow['id'] || index + 1;
                    const customerName = cleanRow['ì´ë¦„'] || cleanRow['name'] || cleanRow['ê³ ê°ëª…'] || `ê³ ê°${customerId}`;
                    const age = parseInt(cleanRow['ì—°ë ¹'] || cleanRow['age']) || 0;
                    const purchaseAmount = parseFloat(cleanRow['1íšŒêµ¬ë§¤ê°€ê²©'] || cleanRow['êµ¬ë§¤ê¸ˆì•¡'] || cleanRow['ê°€ê²©']) || 0;
                    const product = cleanRow['êµ¬ë§¤ìƒí’ˆ'] || cleanRow['ìƒí’ˆ'] || cleanRow['product'] || 'ì•Œ ìˆ˜ ì—†ìŒ';
                    const category = cleanRow['ì¹´í…Œê³ ë¦¬'] || cleanRow['category'] || cleanRow['ë¶„ë¥˜'] || 'ê¸°íƒ€';
                    const purchaseDate = cleanRow['êµ¬ë§¤ì¼'] || cleanRow['date'] || cleanRow['purchase_date'] || '2024-01-01';
                    
                    if (!customerId || purchaseAmount <= 0) return;
                    
                    if (!customerGroups[customerId]) {
                        customerGroups[customerId] = {
                            id: customerId,
                            name: customerName,
                            age: age || 0,
                            purchases: [],
                            categories: new Set(),
                            products: new Set()
                        };
                    }
                    
                    customerGroups[customerId].purchases.push({
                        amount: purchaseAmount,
                        product: product,
                        category: category,
                        date: purchaseDate
                    });
                    
                    customerGroups[customerId].categories.add(category);
                    customerGroups[customerId].products.add(product);
                    
                    if (!customerGroups[customerId].age && age > 0) {
                        customerGroups[customerId].age = age;
                    }
                } catch (error) {
                    console.warn(`í–‰ ${index + 1} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:`, error);
                }
            });
            
            const today = new Date();
            const processedCustomers = Object.values(customerGroups).map(customer => {
                try {
                    const purchases = customer.purchases || [];
                    if (purchases.length === 0) return null;
                    
                    const frequency = purchases.length;
                    const monetary = purchases.reduce((sum, p) => sum + (p.amount || 0), 0);
                    const avgOrderValue = frequency > 0 ? Math.round(monetary / frequency) : 0;
                    
                    let recency = 180;
                    const dates = purchases.map(p => p.date).filter(d => d && d !== '');
                    if (dates.length > 0) {
                        try {
                            const latestDate = new Date(Math.max(...dates.map(d => new Date(d))));
                            if (!isNaN(latestDate.getTime())) {
                                recency = Math.floor((today - latestDate) / (1000 * 60 * 60 * 24));
                            }
                        } catch (dateError) {
                            console.warn('ë‚ ì§œ ì²˜ë¦¬ ì˜¤ë¥˜:', dateError);
                            recency = Math.floor(Math.random() * 180) + 1;
                        }
                    }
                    
                    const lastPurchaseDate = dates.length > 0 ? dates[dates.length - 1] : 
                        new Date(today.getTime() - recency * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                    
                    const categoryDiversity = customer.categories ? customer.categories.size : 1;
                    const productDiversity = customer.products ? customer.products.size : 1;
                    const avgPurchaseInterval = frequency > 1 ? Math.round(recency / (frequency - 1)) : recency;
                    
                    const categoryCount = {};
                    purchases.forEach(p => {
                        const cat = p.category || 'ê¸°íƒ€';
                        categoryCount[cat] = (categoryCount[cat] || 0) + 1;
                    });
                    const favoriteCategory = Object.keys(categoryCount).length > 0 ? 
                        Object.keys(categoryCount).reduce((a, b) => categoryCount[a] > categoryCount[b] ? a : b, 'ê¸°íƒ€') : 'ê¸°íƒ€';
                    
                    return {
                        id: customer.id,
                        name: customer.name || `ê³ ê°${customer.id}`,
                        age: Math.max(18, Math.min(80, customer.age)) || Math.floor(Math.random() * 40) + 25,
                        totalSpent: monetary,
                        purchaseCount: frequency,
                        avgOrderValue: avgOrderValue,
                        daysSinceLastPurchase: Math.max(0, recency),
                        lastPurchaseDate: lastPurchaseDate,
                        categoryDiversity: categoryDiversity,
                        productDiversity: productDiversity,
                        favoriteCategory: favoriteCategory,
                        avgPurchaseInterval: avgPurchaseInterval,
                        recencyScore: 0,
                        frequencyScore: 0,
                        monetaryScore: 0,
                        cluster: null,
                        purchases: purchases
                    };
                } catch (error) {
                    console.warn('ê³ ê° ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                    return null;
                }
            }).filter(customer => customer !== null);
            
            if (processedCustomers.length > 0) {
                try {
                    calculateRFMScores(processedCustomers);
                } catch (error) {
                    console.warn('RFM ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜:', error);
                }
            }
            
            return processedCustomers;
        }
        
        // RFM ì ìˆ˜ ê³„ì‚° (ì•ˆì „í•œ ì²˜ë¦¬)
        function calculateRFMScores(customers) {
            try {
                const recencyValues = customers.map(c => c.daysSinceLastPurchase || 0).sort((a, b) => a - b);
                const frequencyValues = customers.map(c => c.purchaseCount || 0).sort((a, b) => b - a);
                const monetaryValues = customers.map(c => c.totalSpent || 0).sort((a, b) => b - a);
                
                const getQuintile = (value, values, reverse = false) => {
                    if (values.length === 0) return 3;
                    const index = values.indexOf(value);
                    if (index === -1) return 3;
                    let quintile = Math.ceil((index + 1) / values.length * 5);
                    quintile = Math.max(1, Math.min(5, quintile));
                    return reverse ? 6 - quintile : quintile;
                };
                
                customers.forEach(customer => {
                    customer.recencyScore = getQuintile(customer.daysSinceLastPurchase || 0, recencyValues, true);
                    customer.frequencyScore = getQuintile(customer.purchaseCount || 0, frequencyValues);
                    customer.monetaryScore = getQuintile(customer.totalSpent || 0, monetaryValues);
                });
            } catch (error) {
                console.warn('RFM ì ìˆ˜ ê³„ì‚° ì¤‘ ì˜¤ë¥˜:', error);
                // ê¸°ë³¸ê°’ ì„¤ì •
                customers.forEach(customer => {
                    customer.recencyScore = 3;
                    customer.frequencyScore = 3;
                    customer.monetaryScore = 3;
                });
            }
        }
        
        // ì—…ë¡œë“œ ìƒíƒœ í‘œì‹œ
        function showUploadStatus(message, type) {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.textContent = message;
            statusDiv.className = `upload-info upload-${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        // ê°€ì§œ ë°ì´í„° ìƒì„±
        function generateData() {
            customerData = [];
            const surnames = ['ê¹€', 'ì´', 'ë°•', 'ìµœ', 'ì •', 'ê°•', 'ì†', 'ì¡°', 'ìœ¤', 'ì¥'];
            const givenNames = ['ë¯¼ìˆ˜', 'ì˜í¬', 'ì² ìˆ˜', 'ì˜ìˆ˜', 'ë¯¼ì•„', 'íƒœì§„', 'ë¯¸ê²½', 'í˜„ìš°', 'ì„œì—°', 'ë™í˜'];
            const categories = ['ì±„ì†Œ', 'ê³¼ì¼', 'ìœ¡ë¥˜', 'ìœ ì œí’ˆ', 'ì¦‰ì„ì‹í’ˆ', 'ìƒí™œìš©í’ˆ', 'ì˜ë¥˜', 'ì „ìì œí’ˆ'];
            const products = {
                'ì±„ì†Œ': ['ë‹¹ê·¼', 'ì‹œê¸ˆì¹˜', 'ì–‘íŒŒ', 'ë¸Œë¡œì½œë¦¬', 'ìƒì¶”'],
                'ê³¼ì¼': ['ì‚¬ê³¼', 'ë°”ë‚˜ë‚˜', 'ì˜¤ë Œì§€', 'ë”¸ê¸°', 'í¬ë„'],
                'ìœ¡ë¥˜': ['ì†Œê³ ê¸°', 'ë¼ì§€ê³ ê¸°', 'ë‹­ê³ ê¸°', 'ì˜¤ë¦¬ê³ ê¸°'],
                'ìœ ì œí’ˆ': ['ìš°ìœ ', 'ìš”ê±°íŠ¸', 'ì¹˜ì¦ˆ', 'ë²„í„°'],
                'ì¦‰ì„ì‹í’ˆ': ['ë¼ë©´', 'ê¹€ë°¥', 'ë„ì‹œë½', 'í–„ë²„ê±°'],
                'ìƒí™œìš©í’ˆ': ['ì„¸ì œ', 'í™”ì¥ì§€', 'ìƒ´í‘¸', 'ì¹˜ì•½'],
                'ì˜ë¥˜': ['í‹°ì…”ì¸ ', 'ì²­ë°”ì§€', 'ì›í”¼ìŠ¤', 'ìì¼“'],
                'ì „ìì œí’ˆ': ['ìŠ¤ë§ˆíŠ¸í°', 'ë…¸íŠ¸ë¶', 'ì´ì–´í°', 'ì¶©ì „ê¸°']
            };
            
            for (let i = 1; i <= 1000; i++) {
                const surname = surnames[Math.floor(Math.random() * surnames.length)];
                const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
                
                const ageGroup = Math.random();
                let age, purchases = [];
                
                if (ageGroup < 0.2) {
                    age = Math.floor(Math.random() * 10) + 20;
                } else if (ageGroup < 0.5) {
                    age = Math.floor(Math.random() * 10) + 30;
                } else if (ageGroup < 0.8) {
                    age = Math.floor(Math.random() * 10) + 40;
                } else {
                    age = Math.floor(Math.random() * 20) + 50;
                }
                
                // ì—°ë ¹ëŒ€ë³„ êµ¬ë§¤ íŒ¨í„´ ìƒì„±
                const purchaseCount = Math.floor(Math.random() * 20) + 3;
                for (let j = 0; j < purchaseCount; j++) {
                    const category = categories[Math.floor(Math.random() * categories.length)];
                    const productList = products[category];
                    const product = productList[Math.floor(Math.random() * productList.length)];
                    const amount = Math.floor(Math.random() * 50000) + 5000;
                    const daysAgo = Math.floor(Math.random() * 365);
                    const purchaseDate = new Date();
                    purchaseDate.setDate(purchaseDate.getDate() - daysAgo);
                    
                    purchases.push({
                        amount: amount,
                        product: product,
                        category: category,
                        date: purchaseDate.toISOString().split('T')[0]
                    });
                }
                
                const totalSpent = purchases.reduce((sum, p) => sum + p.amount, 0);
                const avgOrderValue = Math.round(totalSpent / purchases.length);
                const latestPurchase = new Date(Math.max(...purchases.map(p => new Date(p.date))));
                const daysSinceLastPurchase = Math.floor((new Date() - latestPurchase) / (1000 * 60 * 60 * 24));
                
                const categorySet = new Set(purchases.map(p => p.category));
                const categoryCount = {};
                purchases.forEach(p => {
                    categoryCount[p.category] = (categoryCount[p.category] || 0) + 1;
                });
                const favoriteCategory = Object.keys(categoryCount).reduce((a, b) => 
                    categoryCount[a] > categoryCount[b] ? a : b);
                
                customerData.push({
                    id: i,
                    name: `${surname}${givenName}`,
                    age: age,
                    totalSpent: totalSpent,
                    purchaseCount: purchases.length,
                    avgOrderValue: avgOrderValue,
                    daysSinceLastPurchase: daysSinceLastPurchase,
                    lastPurchaseDate: latestPurchase.toISOString().split('T')[0],
                    categoryDiversity: categorySet.size,
                    productDiversity: new Set(purchases.map(p => p.product)).size,
                    favoriteCategory: favoriteCategory,
                    avgPurchaseInterval: Math.round(365 / purchases.length),
                    recencyScore: 0,
                    frequencyScore: 0,
                    monetaryScore: 0,
                    cluster: null,
                    purchases: purchases
                });
            }
            
            calculateRFMScores(customerData);
            updateStats();
            updateTable();
            runClustering();
        }
        
        function euclideanDistance(point1, point2) {
            return Math.sqrt(
                point1.reduce((sum, val, index) => sum + Math.pow(val - point2[index], 2), 0)
            );
        }
        
        // í´ëŸ¬ìŠ¤í„° íŠ¹ì„± ë¶„ì„ (ì§„ì§œ AI ë¶„ì„)
        async function analyzeClusterCharacteristics() {
            const clusters = [...new Set(customerData.map(c => c.cluster))].filter(c => c !== null);
            
            document.getElementById('aiAnalysis').style.display = 'block';
            document.getElementById('clusterAnalysis').innerHTML = '<div class="loading">ğŸ¤– AIê°€ ê° í´ëŸ¬ìŠ¤í„°ë¥¼ ì‹¬ì¸µ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...<br>ì‹¤ì œ êµ¬ë§¤ íŒ¨í„´ê³¼ í–‰ë™ ë°ì´í„°ë¥¼ ì¢…í•©í•˜ì—¬ ì¸ì‚¬ì´íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</div>';
            
            let analysisHTML = '<div class="cluster-cards">';
            
            for (const clusterId of clusters) {
                const clusterData = customerData.filter(c => c.cluster === clusterId);
                const count = clusterData.length;
                const percentage = Math.round(count/customerData.length*100);
                
                const clusterStats = {
                    clusterId: clusterId + 1,
                    count,
                    percentage
                };
                
                // ì‹¤ì œ AI ë¶„ì„ í˜¸ì¶œ
                const analysis = await analyzeClusterWithAI(clusterData, clusterStats);
                
                // í´ëŸ¬ìŠ¤í„° ë©”íŠ¸ë¦­ ê³„ì‚°
                const avgAge = Math.round(clusterData.reduce((sum, c) => sum + c.age, 0) / count);
                const avgSpent = Math.round(clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / count);
                const avgPurchases = Math.round(clusterData.reduce((sum, c) => sum + c.purchaseCount, 0) / count * 10) / 10;
                const avgOrderValue = Math.round(clusterData.reduce((sum, c) => sum + c.avgOrderValue, 0) / count);
                
                analysisHTML += `
                    <div class="cluster-card cluster-${clusterId}">
                        <div class="cluster-title">í´ëŸ¬ìŠ¤í„° ${clusterId + 1}: ${analysis.name}</div>
                        <div class="cluster-subtitle">ê³ ê° ${count}ëª… (${percentage}%)</div>
                        
                        <div class="cluster-metrics">
                            <div class="metric">
                                <div class="metric-value">${avgAge}ì„¸</div>
                                <div class="metric-label">í‰ê·  ì—°ë ¹</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgSpent.toLocaleString()}ì›</div>
                                <div class="metric-label">í‰ê·  êµ¬ë§¤ì•¡</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgPurchases}íšŒ</div>
                                <div class="metric-label">í‰ê·  êµ¬ë§¤íšŸìˆ˜</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgOrderValue.toLocaleString()}ì›</div>
                                <div class="metric-label">í‰ê·  ì£¼ë¬¸ê°€ê²©</div>
                            </div>
                        </div>
                        
                        <div class="ai-insights">
                            <div class="insight-title">ğŸ§  AI ë¶„ì„ ì¸ì‚¬ì´íŠ¸</div>
                            <div class="insight-text">${analysis.insights}</div>
                        </div>
                        
                        <div class="ai-strategy">
                            <div class="strategy-title">ğŸ¯ ì¶”ì²œ ì•¡ì…˜í”Œëœ</div>
                            <div>${analysis.strategy}</div>
                        </div>
                    </div>
                `;
            }
            
            analysisHTML += '</div>';
            document.getElementById('clusterAnalysis').innerHTML = analysisHTML;
        }
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            const totalCustomers = customerData.length;
            const avgAge = Math.round(customerData.reduce((sum, c) => sum + c.age, 0) / totalCustomers);
            const avgSpent = Math.round(customerData.reduce((sum, c) => sum + c.totalSpent, 0) / totalCustomers);
            const avgPurchases = Math.round(customerData.reduce((sum, c) => sum + c.purchaseCount, 0) / totalCustomers * 10) / 10;
            
            const clusterCounts = {};
            customerData.forEach(c => {
                if (c.cluster !== null) {
                    clusterCounts[c.cluster] = (clusterCounts[c.cluster] || 0) + 1;
                }
            });
            
            const statsHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalCustomers}</div>
                    <div class="stat-label">ì´ ê³ ê° ìˆ˜</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgAge}ì„¸</div>
                    <div class="stat-label">í‰ê·  ì—°ë ¹</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgSpent.toLocaleString()}ì›</div>
                    <div class="stat-label">í‰ê·  êµ¬ë§¤ì•¡</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgPurchases}íšŒ</div>
                    <div class="stat-label">í‰ê·  êµ¬ë§¤íšŸìˆ˜</div>
                </div>
                ${Object.keys(clusterCounts).map(cluster => `
                    <div class="stat-card">
                        <div class="stat-value">${clusterCounts[cluster]}</div>
                        <div class="stat-label">í´ëŸ¬ìŠ¤í„° ${parseInt(cluster) + 1}</div>
                    </div>
                `).join('')}
            `;
            
            document.getElementById('statsGrid').innerHTML = statsHTML;
        }
        
        // í…Œì´ë¸” ì—…ë°ì´íŠ¸
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = customerData.slice(0, 50).map(customer => `
                <tr class="cluster-${customer.cluster || 0}">
                    <td>${customer.id}</td>
                    <td>${customer.name}</td>
                    <td>${customer.age}ì„¸</td>
                    <td>${customer.totalSpent.toLocaleString()}ì›</td>
                    <td>${customer.purchaseCount}íšŒ</td>
                    <td>${customer.avgOrderValue.toLocaleString()}ì›</td>
                    <td>${customer.favoriteCategory || '-'}</td>
                    <td>R${customer.recencyScore || 0}F${customer.frequencyScore || 0}M${customer.monetaryScore || 0}</td>
                    <td>${customer.cluster !== null ? `í´ëŸ¬ìŠ¤í„° ${customer.cluster + 1}` : '-'}</td>
                </tr>
            `).join('');
        }
        
        // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateCharts() {
            const colors = ['#FF6B6B', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'];
            
            const scatterData = {
                datasets: []
            };
            
            const clusters = [...new Set(customerData.map(c => c.cluster))].filter(c => c !== null);
            clusters.forEach(cluster => {
                const clusterData = customerData.filter(c => c.cluster === cluster);
                scatterData.datasets.push({
                    label: `í´ëŸ¬ìŠ¤í„° ${cluster + 1}`,
                    data: clusterData.map(c => ({ x: c.age, y: c.totalSpent })),
                    backgroundColor: colors[cluster],
                    borderColor: colors[cluster],
                    pointBorderWidth: 2,
                    pointRadius: 4
                });
            });
            
            if (scatterChart) scatterChart.destroy();
            scatterChart = new Chart(document.getElementById('scatterChart'), {
                type: 'scatter',
                data: scatterData,
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'ì—°ë ¹ë³„ ì´ êµ¬ë§¤ê¸ˆì•¡ ë¶„í¬'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'ì—°ë ¹'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'ì´ êµ¬ë§¤ê¸ˆì•¡ (ì›)'
                            }
                        }
                    }
                }
            });
            
            const clusterAvgs = {};
            clusters.forEach(cluster => {
                const clusterData = customerData.filter(c => c.cluster === cluster);
                clusterAvgs[cluster] = clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / clusterData.length;
            });
            
            if (barChart) barChart.destroy();
            barChart = new Chart(document.getElementById('barChart'), {
                type: 'bar',
                data: {
                    labels: clusters.map(c => `í´ëŸ¬ìŠ¤í„° ${c + 1}`),
                    datasets: [{
                        label: 'í‰ê·  êµ¬ë§¤ê¸ˆì•¡',
                        data: clusters.map(c => clusterAvgs[c]),
                        backgroundColor: clusters.map(c => colors[c]),
                        borderColor: clusters.map(c => colors[c]),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'í´ëŸ¬ìŠ¤í„°ë³„ í‰ê·  êµ¬ë§¤ê¸ˆì•¡'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'í‰ê·  êµ¬ë§¤ê¸ˆì•¡ (ì›)'
                            }
                        }
                    }
                }
            });
        }
        
        // CSV ë‹¤ìš´ë¡œë“œ
        function downloadCSV() {
            const headers = ['ê³ ê°ID', 'ì´ë¦„', 'ì—°ë ¹', 'ì´êµ¬ë§¤ê¸ˆì•¡', 'êµ¬ë§¤íšŸìˆ˜', 'í‰ê· ì£¼ë¬¸ê°€ê²©', 'ì„ í˜¸ì¹´í…Œê³ ë¦¬', 'RFMì ìˆ˜', 'í´ëŸ¬ìŠ¤í„°'];
            const csvContent = [
                headers.join(','),
                ...customerData.map(customer => [
                    customer.id,
                    customer.name,
                    customer.age,
                    customer.totalSpent,
                    customer.purchaseCount,
                    customer.avgOrderValue,
                    customer.favoriteCategory || '',
                    `R${customer.recencyScore}F${customer.frequencyScore}M${customer.monetaryScore}`,
                    customer.cluster !== null ? customer.cluster + 1 : ''
                ].join(','))
            ].join('\n');
            
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'ai_customer_clustering_results.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // CSV í…œí”Œë¦¿ ë‹¤ìš´ë¡œë“œ
        function downloadTemplate() {
            const templateData = [
                ['ê³ ê°ID', 'ì´ë¦„', 'ì—°ë ¹', '1íšŒêµ¬ë§¤ê°€ê²©', 'êµ¬ë§¤ìƒí’ˆ', 'ì¹´í…Œê³ ë¦¬', 'êµ¬ë§¤ì¼'].join(','),
                [1, 'ê¹€ë¯¼ìˆ˜', 35, 50000, 'ë‹¹ê·¼', 'ì±„ì†Œ', '2024-05-15'].join(','),
                [1, 'ê¹€ë¯¼ìˆ˜', 35, 500000, 'ì‹œê¸ˆì¹˜', 'ì±„ì†Œ', '2024-05-15'].join(','),
                [2, 'ì´ì˜í¬', 28, 350000, 'ê¹€ë°¥', 'ì¦‰ì„ì‹í’ˆ', '2024-05-20'].join(','),
                [3, 'ë°•ì² ìˆ˜', 42, 750000, 'ë‹­ê°€ìŠ´ì‚´', 'ìœ¡ë¥˜', '2024-05-10'].join(','),
                [3, 'ë°•ì² ìˆ˜', 42, 750000, 'ìƒ¤ë¸Œìƒ¤ë¸Œìš© ëƒ‰ë™ ëª©
