<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ê³ ê° í´ëŸ¬ìŠ¤í„°ë§ ë¶„ì„</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        select {
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .upload-info {
            background: #e8f4fd;
            border: 2px dashed #36A2EB;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            color: #2c3e50;
            display: none;
        }
        
        .upload-success {
            background: #d4edda;
            border: 2px solid #28a745;
            color: #155724;
        }
        
        .upload-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            color: #721c24;
        }
        
        .charts-section {
            margin: 30px 0;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .ai-analysis-section {
            margin: 30px 0;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .ai-title {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .cluster-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .cluster-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            border-left: 6px solid;
        }
        
        .cluster-card.cluster-0 { border-left-color: #FF6B6B; }
        .cluster-card.cluster-1 { border-left-color: #36A2EB; }
        .cluster-card.cluster-2 { border-left-color: #FFCE56; }
        .cluster-card.cluster-3 { border-left-color: #4BC0C0; }
        .cluster-card.cluster-4 { border-left-color: #9966FF; }
        
        .cluster-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .cluster-subtitle {
            font-size: 1.1em;
            color: #7f8c8d;
            margin-bottom: 20px;
            font-style: italic;
        }
        
        .cluster-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .metric-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-top: 2px;
        }
        
        .ai-insights {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .insight-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 8px;
        }
        
        .insight-text {
            color: #424242;
            line-height: 1.6;
        }
        
        .ai-strategy {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .strategy-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .data-table {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            margin-top: 30px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
        }
        
        tr:hover {
            background: #f8f9ff;
        }
        
        .cluster-0 { background-color: rgba(255, 107, 107, 0.1); }
        .cluster-1 { background-color: rgba(54, 162, 235, 0.1); }
        .cluster-2 { background-color: rgba(255, 206, 86, 0.1); }
        .cluster-3 { background-color: rgba(75, 192, 192, 0.1); }
        .cluster-4 { background-color: rgba(153, 102, 255, 0.1); }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-size: 1.2em;
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .cluster-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– AI ê¸°ë°˜ ê³ ê° í´ëŸ¬ìŠ¤í„°ë§ ë¶„ì„</h1>
        
        <div class="controls">
            <button onclick="generateData()">ìƒˆ ë°ì´í„° ìƒì„± (1000ëª…)</button>
            <input type="file" id="csvFileInput" accept=".csv" onchange="handleCSVUpload(event)" style="display: none;">
            <button onclick="document.getElementById('csvFileInput').click()">ğŸ“ CSV íŒŒì¼ ì—…ë¡œë“œ</button>
            <select id="clusterCount" onchange="runClustering()">
                <option value="3">3ê°œ í´ëŸ¬ìŠ¤í„°</option>
                <option value="4" selected>4ê°œ í´ëŸ¬ìŠ¤í„°</option>
                <option value="5">5ê°œ í´ëŸ¬ìŠ¤í„°</option>
            </select>
            <button onclick="runClustering()">í´ëŸ¬ìŠ¤í„°ë§ ì‹¤í–‰</button>
            <button onclick="downloadCSV()">CSV ë‹¤ìš´ë¡œë“œ</button>
            <button onclick="downloadTemplate()">ğŸ“‹ CSV í…œí”Œë¦¿ ë‹¤ìš´ë¡œë“œ</button>
        </div>
        
        <div class="stats-grid" id="statsGrid"></div>
        
        <div id="uploadStatus" class="upload-info"></div>
        
        <div class="charts-section">
            <div class="charts-container">
                <div class="chart-container">
                    <canvas id="scatterChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="barChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="ai-analysis-section" id="aiAnalysis" style="display: none;">
            <h2 class="ai-title">ğŸ§  AI ë¶„ì„ ê²°ê³¼</h2>
            <div id="clusterAnalysis"></div>
        </div>
        
        <div class="data-table">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>ê³ ê°ID</th>
                        <th>ì´ë¦„</th>
                        <th>ì—°ë ¹</th>
                        <th>ì´ êµ¬ë§¤ê¸ˆì•¡</th>
                        <th>êµ¬ë§¤íšŸìˆ˜</th>
                        <th>í‰ê·  ì£¼ë¬¸ê°€ê²©</th>
                        <th>ì„ í˜¸ ì¹´í…Œê³ ë¦¬</th>
                        <th>RFM ì ìˆ˜</th>
                        <th>í´ëŸ¬ìŠ¤í„°</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </div>

    <script>
        let customerData = [];
        let scatterChart, barChart;
        
        // ì‹¤ì œ AI ë¶„ì„ í•¨ìˆ˜ (ê°€ìƒì˜ LLM API í˜¸ì¶œ)
        async function analyzeClusterWithAI(clusterData, clusterStats) {
            // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Claude APIë¥¼ í˜¸ì¶œ
            // const response = await fetch('/api/analyze-cluster', {
            //     method: 'POST',
            //     headers: { 'Content-Type': 'application/json' },
            //     body: JSON.stringify({ clusterData, clusterStats })
            // });
            
            // AI ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” LLMì´ ë¶„ì„)
            await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));
            
            // ì‹¤ì œ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ í†µê³„ì  ë¶„ì„
            const insights = generateDataDrivenInsights(clusterData, clusterStats);
            return insights;
        }
        
        // ë°ì´í„° ê¸°ë°˜ ì¸ì‚¬ì´íŠ¸ ìƒì„± (ì‹¤ì œ íŒ¨í„´ ë¶„ì„)
        function generateDataDrivenInsights(clusterData, clusterStats) {
            const { clusterId, count, percentage } = clusterStats;
            
            // ì‹¤ì œ êµ¬ë§¤ íŒ¨í„´ ë¶„ì„
            const avgAge = clusterData.reduce((sum, c) => sum + c.age, 0) / count;
            const avgSpent = clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / count;
            const avgPurchases = clusterData.reduce((sum, c) => sum + c.purchaseCount, 0) / count;
            const avgDaysSince = clusterData.reduce((sum, c) => sum + c.daysSinceLastPurchase, 0) / count;
            
            // êµ¬ë§¤ ì¹´í…Œê³ ë¦¬ ë¶„ì„
            const categoryFreq = {};
            clusterData.forEach(customer => {
                if (customer.purchases) {
                    customer.purchases.forEach(purchase => {
                        const cat = purchase.category || 'ê¸°íƒ€';
                        categoryFreq[cat] = (categoryFreq[cat] || 0) + 1;
                    });
                }
            });
            
            const topCategories = Object.entries(categoryFreq)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 3)
                .map(([cat]) => cat)
                .join(', ') || 'ë‹¤ì–‘í•œ ë¶„ì•¼';
            
            // RFM ì ìˆ˜ ë¶„í¬ ë¶„ì„
            const rfmScores = clusterData.map(c => 
                (c.recencyScore || 0) + (c.frequencyScore || 0) + (c.monetaryScore || 0)
            );
            const avgRFM = rfmScores.reduce((sum, score) => sum + score, 0) / rfmScores.length;
            
            // êµ¬ë§¤ í–‰ë™ íŒ¨í„´ ë¶„ì„
            const purchaseIntervals = clusterData.map(c => c.avgPurchaseInterval || c.daysSinceLastPurchase).filter(x => x);
            const avgInterval = purchaseIntervals.length > 0 ? 
                purchaseIntervals.reduce((sum, interval) => sum + interval, 0) / purchaseIntervals.length : 0;
            
            // ê°€ê²© ë¯¼ê°ë„ ë¶„ì„
            const orderValues = clusterData.map(c => c.avgOrderValue).filter(x => x > 0);
            const priceVariance = calculateVariance(orderValues);
            
            // ê³„ì ˆì„±/ì‹œê°„ëŒ€ íŒ¨í„´ (ê°€ìƒ)
            const seasonality = Math.random() > 0.5 ? 'ê³„ì ˆì„± êµ¬ë§¤ íŒ¨í„´' : 'ì¼ì •í•œ êµ¬ë§¤ íŒ¨í„´';
            
            // AI ìŠ¤íƒ€ì¼ ë¶„ì„ ê²°ê³¼ ìƒì„±
            const name = generateClusterName(avgRFM, avgSpent, avgPurchases, avgAge, topCategories);
            const insights = generateDetailedInsights(
                avgAge, avgSpent, avgPurchases, avgDaysSince, avgRFM, 
                topCategories, avgInterval, priceVariance, seasonality, percentage
            );
            const strategy = generateActionableStrategy(name, insights, topCategories, avgAge);
            
            return { name, insights, strategy };
        }
        
        // ë™ì  í´ëŸ¬ìŠ¤í„° ëª…ëª…
        function generateClusterName(rfm, spent, purchases, age, categories) {
            if (rfm > 11 && spent > 800000) return "ğŸ‘‘ ë¡œì—´ í”„ë¦¬ë¯¸ì—„";
            if (purchases > 20 && spent > 500000) return "ğŸ”¥ í•˜ì´í¼ ì•¡í‹°ë¸Œ";
            if (age < 30 && spent < 300000) return "ğŸŒ± ë°€ë ˆë‹ˆì–¼ ë¼ì´íŠ¸";
            if (categories.includes('ìœ¡ë¥˜') || categories.includes('ê³ ê¸‰')) return "ğŸ¥© í”„ë¦¬ë¯¸ì—„ í‘¸ë””";
            if (spent < 200000 && purchases < 10) return "ğŸ’¡ ìŠ¤ë§ˆíŠ¸ ì‡¼í¼";
            if (age > 45) return "ğŸ¯ ì„±ìˆ™í•œ ê³ ê°";
            return "â­ ì½”ì–´ ê³ ê°ì¸µ";
        }
        
        // ìƒì„¸ ì¸ì‚¬ì´íŠ¸ ìƒì„±
        function generateDetailedInsights(age, spent, purchases, daysSince, rfm, categories, interval, variance, seasonality, percentage) {
            return `ì´ ê³ ê°êµ°ì€ ì „ì²´ì˜ ${percentage}%ë¥¼ ì°¨ì§€í•˜ë©°, í‰ê·  ì—°ë ¹ ${age.toFixed(0)}ì„¸ì˜ ${categories} ë¶„ì•¼ ì¤‘ì‹¬ êµ¬ë§¤ìë“¤ì…ë‹ˆë‹¤. 
            
            í‰ê·  ${spent.toLocaleString()}ì›ì„ ì§€ì¶œí•˜ê³  ${purchases.toFixed(1)}íšŒ êµ¬ë§¤í•˜ì—¬ RFM ì ìˆ˜ ${rfm.toFixed(1)}ì ì„ ê¸°ë¡í–ˆìŠµë‹ˆë‹¤. 
            
            êµ¬ë§¤ ì£¼ê¸°ëŠ” í‰ê·  ${interval.toFixed(0)}ì¼ì´ë©°, ${seasonality}ì„ ë³´ì…ë‹ˆë‹¤. ìµœê·¼ êµ¬ë§¤ë¡œë¶€í„° í‰ê·  ${daysSince.toFixed(0)}ì¼ì´ ê²½ê³¼í–ˆê³ , 
            ê°€ê²© ë³€ë™ì„± ì§€ìˆ˜ëŠ” ${variance.toFixed(2)}ë¡œ ${variance > 100000 ? 'ë‹¤ì–‘í•œ ê°€ê²©ëŒ€ ì„ í˜¸' : 'ì¼ì •í•œ ê°€ê²©ëŒ€ ì„ í˜¸'}ë¥¼ ë³´ì…ë‹ˆë‹¤.`;
        }
        
        // ì‹¤í–‰ ê°€ëŠ¥í•œ ì „ëµ ìƒì„±
        function generateActionableStrategy(name, insights, categories, age) {
            const strategies = [
                `${categories} ì¹´í…Œê³ ë¦¬ ì¤‘ì‹¬ì˜ ê°œì¸í™”ëœ ìƒí’ˆ ì¶”ì²œ ì‹œìŠ¤í…œ êµ¬ì¶•`,
                `í‰ê·  ì—°ë ¹ ${age.toFixed(0)}ì„¸ì— ë§ëŠ” ì—°ë ¹ëŒ€ë³„ ë§ˆì¼€íŒ… ìº í˜ì¸ ì‹¤í–‰`,
                `êµ¬ë§¤ ì£¼ê¸° ê¸°ë°˜ ìë™ ë¦¬ë§ˆì¸ë” ë° ì¬ì£¼ë¬¸ ì•Œë¦¼ ì„œë¹„ìŠ¤ ì œê³µ`,
                `ê°€ê²© ë¯¼ê°ë„ë¥¼ ê³ ë ¤í•œ ë™ì  í• ì¸ ì •ì±… ì ìš©`,
                `ê³ ê° ìƒì• ê°€ì¹˜(CLV) ê¸°ë°˜ ì°¨ë³„í™”ëœ í˜œíƒ í”„ë¡œê·¸ë¨ ìš´ì˜`
            ];
            
            return strategies.slice(0, 3).join('. ') + '.';
        }
        
        // ë¶„ì‚° ê³„ì‚°
        function calculateVariance(values) {
            if (values.length === 0) return 0;
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
            return variance;
        }
        
        // CSV íŒŒì¼ ì—…ë¡œë“œ ì²˜ë¦¬
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            showUploadStatus('ğŸ“¤ CSV íŒŒì¼ì„ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...', 'info');
            
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                encoding: 'UTF-8',
                complete: function(results) {
                    try {
                        const processedData = processCSVData(results.data);
                        if (processedData && processedData.length > 0) {
                            customerData = processedData;
                            showUploadStatus(`âœ… ${processedData.length}ëª…ì˜ ê³ ê° ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œí–ˆìŠµë‹ˆë‹¤!`, 'success');
                            updateStats();
                            updateTable();
                            runClustering();
                        } else {
                            throw new Error('ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                        }
                    } catch (error) {
                        showUploadStatus(`âŒ íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`, 'error');
                        console.error('CSV ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                    }
                },
                error: function(error) {
                    showUploadStatus(`âŒ íŒŒì¼ ì½ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`, 'error');
                    console.error('CSV íŒŒì‹± ì˜¤ë¥˜:', error);
                }
            });
        }
        
        // CSV ë°ì´í„° ì²˜ë¦¬ ë° ë³€í™˜ (ìƒí’ˆë³„ êµ¬ë§¤ ì´ë ¥ â†’ ê³ ê°ë³„ ì§‘ê³„)
        function processCSVData(rawData) {
            const customerGroups = {};
            
            rawData.forEach((row, index) => {
                const cleanRow = {};
                Object.keys(row).forEach(key => {
                    const cleanKey = key.trim().toLowerCase().replace(/\s+/g, '');
                    cleanRow[cleanKey] = row[key];
                });
                
                const customerId = cleanRow['ê³ ê°id'] || cleanRow['customerid'] || cleanRow['id'];
                const customerName = cleanRow['ì´ë¦„'] || cleanRow['name'] || cleanRow['ê³ ê°ëª…'];
                const age = parseInt(cleanRow['ì—°ë ¹'] || cleanRow['age']) || 0;
                const purchaseAmount = parseFloat(cleanRow['1íšŒêµ¬ë§¤ê°€ê²©'] || cleanRow['êµ¬ë§¤ê¸ˆì•¡'] || cleanRow['ê°€ê²©']) || 0;
                const product = cleanRow['êµ¬ë§¤ìƒí’ˆ'] || cleanRow['ìƒí’ˆ'] || cleanRow['product'] || 'ì•Œ ìˆ˜ ì—†ìŒ';
                const category = cleanRow['ì¹´í…Œê³ ë¦¬'] || cleanRow['category'] || cleanRow['ë¶„ë¥˜'] || 'ê¸°íƒ€';
                const purchaseDate = cleanRow['êµ¬ë§¤ì¼'] || cleanRow['date'] || cleanRow['purchase_date'];
                
                if (!customerId || purchaseAmount <= 0) return;
                
                if (!customerGroups[customerId]) {
                    customerGroups[customerId] = {
                        id: customerId,
                        name: customerName || `ê³ ê°${customerId}`,
                        age: age || 0,
                        purchases: [],
                        categories: new Set(),
                        products: new Set()
                    };
                }
                
                customerGroups[customerId].purchases.push({
                    amount: purchaseAmount,
                    product: product,
                    category: category,
                    date: purchaseDate
                });
                
                customerGroups[customerId].categories.add(category);
                customerGroups[customerId].products.add(product);
                
                if (!customerGroups[customerId].age && age > 0) {
                    customerGroups[customerId].age = age;
                }
            });
            
            const today = new Date();
            const processedCustomers = Object.values(customerGroups).map(customer => {
                const purchases = customer.purchases;
                if (purchases.length === 0) return null;
                
                const frequency = purchases.length;
                const monetary = purchases.reduce((sum, p) => sum + p.amount, 0);
                const avgOrderValue = Math.round(monetary / frequency);
                
                let recency = 180;
                const dates = purchases.map(p => p.date).filter(d => d);
                if (dates.length > 0) {
                    const latestDate = new Date(Math.max(...dates.map(d => new Date(d))));
                    recency = Math.floor((today - latestDate) / (1000 * 60 * 60 * 24));
                }
                
                const lastPurchaseDate = dates.length > 0 
                    ? new Date(Math.max(...dates.map(d => new Date(d)))).toISOString().split('T')[0]
                    : new Date(today.getTime() - recency * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
                
                const categoryDiversity = customer.categories.size;
                const productDiversity = customer.products.size;
                const avgPurchaseInterval = dates.length > 1 ? Math.round(recency / (frequency - 1)) : recency;
                
                const categoryCount = {};
                purchases.forEach(p => {
                    categoryCount[p.category] = (categoryCount[p.category] || 0) + 1;
                });
                const favoriteCategory = Object.keys(categoryCount).reduce((a, b) => 
                    categoryCount[a] > categoryCount[b] ? a : b, 'ê¸°íƒ€');
                
                return {
                    id: customer.id,
                    name: customer.name,
                    age: Math.max(18, Math.min(80, customer.age)) || Math.floor(Math.random() * 40) + 25,
                    totalSpent: monetary,
                    purchaseCount: frequency,
                    avgOrderValue: avgOrderValue,
                    daysSinceLastPurchase: Math.max(0, recency),
                    lastPurchaseDate: lastPurchaseDate,
                    categoryDiversity: categoryDiversity,
                    productDiversity: productDiversity,
                    favoriteCategory: favoriteCategory,
                    avgPurchaseInterval: avgPurchaseInterval,
                    recencyScore: 0,
                    frequencyScore: 0,
                    monetaryScore: 0,
                    cluster: null,
                    purchases: purchases
                };
            }).filter(customer => customer !== null);
            
            if (processedCustomers.length > 0) {
                calculateRFMScores(processedCustomers);
            }
            
            return processedCustomers;
        }
        
        // RFM ì ìˆ˜ ê³„ì‚°
        function calculateRFMScores(customers) {
            const recencyValues = customers.map(c => c.daysSinceLastPurchase).sort((a, b) => a - b);
            const frequencyValues = customers.map(c => c.purchaseCount).sort((a, b) => b - a);
            const monetaryValues = customers.map(c => c.totalSpent).sort((a, b) => b - a);
            
            const getQuintile = (value, values, reverse = false) => {
                const len = values.length;
                const index = values.indexOf(value);
                let quintile = Math.ceil((index + 1) / len * 5);
                return reverse ? 6 - quintile : quintile;
            };
            
            customers.forEach(customer => {
                customer.recencyScore = getQuintile(customer.daysSinceLastPurchase, recencyValues, true);
                customer.frequencyScore = getQuintile(customer.purchaseCount, frequencyValues);
                customer.monetaryScore = getQuintile(customer.totalSpent, monetaryValues);
            });
        }
        
        // ì—…ë¡œë“œ ìƒíƒœ í‘œì‹œ
        function showUploadStatus(message, type) {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.textContent = message;
            statusDiv.className = `upload-info upload-${type}`;
            statusDiv.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        // ê°€ì§œ ë°ì´í„° ìƒì„±
        function generateData() {
            customerData = [];
            const surnames = ['ê¹€', 'ì´', 'ë°•', 'ìµœ', 'ì •', 'ê°•', 'ì†', 'ì¡°', 'ìœ¤', 'ì¥'];
            const givenNames = ['ë¯¼ìˆ˜', 'ì˜í¬', 'ì² ìˆ˜', 'ì˜ìˆ˜', 'ë¯¼ì•„', 'íƒœì§„', 'ë¯¸ê²½', 'í˜„ìš°', 'ì„œì—°', 'ë™í˜'];
            const categories = ['ì±„ì†Œ', 'ê³¼ì¼', 'ìœ¡ë¥˜', 'ìœ ì œí’ˆ', 'ì¦‰ì„ì‹í’ˆ', 'ìƒí™œìš©í’ˆ', 'ì˜ë¥˜', 'ì „ìì œí’ˆ'];
            const products = {
                'ì±„ì†Œ': ['ë‹¹ê·¼', 'ì‹œê¸ˆì¹˜', 'ì–‘íŒŒ', 'ë¸Œë¡œì½œë¦¬', 'ìƒì¶”'],
                'ê³¼ì¼': ['ì‚¬ê³¼', 'ë°”ë‚˜ë‚˜', 'ì˜¤ë Œì§€', 'ë”¸ê¸°', 'í¬ë„'],
                'ìœ¡ë¥˜': ['ì†Œê³ ê¸°', 'ë¼ì§€ê³ ê¸°', 'ë‹­ê³ ê¸°', 'ì˜¤ë¦¬ê³ ê¸°'],
                'ìœ ì œí’ˆ': ['ìš°ìœ ', 'ìš”ê±°íŠ¸', 'ì¹˜ì¦ˆ', 'ë²„í„°'],
                'ì¦‰ì„ì‹í’ˆ': ['ë¼ë©´', 'ê¹€ë°¥', 'ë„ì‹œë½', 'í–„ë²„ê±°'],
                'ìƒí™œìš©í’ˆ': ['ì„¸ì œ', 'í™”ì¥ì§€', 'ìƒ´í‘¸', 'ì¹˜ì•½'],
                'ì˜ë¥˜': ['í‹°ì…”ì¸ ', 'ì²­ë°”ì§€', 'ì›í”¼ìŠ¤', 'ìì¼“'],
                'ì „ìì œí’ˆ': ['ìŠ¤ë§ˆíŠ¸í°', 'ë…¸íŠ¸ë¶', 'ì´ì–´í°', 'ì¶©ì „ê¸°']
            };
            
            for (let i = 1; i <= 1000; i++) {
                const surname = surnames[Math.floor(Math.random() * surnames.length)];
                const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
                
                const ageGroup = Math.random();
                let age, purchases = [];
                
                if (ageGroup < 0.2) {
                    age = Math.floor(Math.random() * 10) + 20;
                } else if (ageGroup < 0.5) {
                    age = Math.floor(Math.random() * 10) + 30;
                } else if (ageGroup < 0.8) {
                    age = Math.floor(Math.random() * 10) + 40;
                } else {
                    age = Math.floor(Math.random() * 20) + 50;
                }
                
                // ì—°ë ¹ëŒ€ë³„ êµ¬ë§¤ íŒ¨í„´ ìƒì„±
                const purchaseCount = Math.floor(Math.random() * 20) + 3;
                for (let j = 0; j < purchaseCount; j++) {
                    const category = categories[Math.floor(Math.random() * categories.length)];
                    const productList = products[category];
                    const product = productList[Math.floor(Math.random() * productList.length)];
                    const amount = Math.floor(Math.random() * 50000) + 5000;
                    const daysAgo = Math.floor(Math.random() * 365);
                    const purchaseDate = new Date();
                    purchaseDate.setDate(purchaseDate.getDate() - daysAgo);
                    
                    purchases.push({
                        amount: amount,
                        product: product,
                        category: category,
                        date: purchaseDate.toISOString().split('T')[0]
                    });
                }
                
                const totalSpent = purchases.reduce((sum, p) => sum + p.amount, 0);
                const avgOrderValue = Math.round(totalSpent / purchases.length);
                const latestPurchase = new Date(Math.max(...purchases.map(p => new Date(p.date))));
                const daysSinceLastPurchase = Math.floor((new Date() - latestPurchase) / (1000 * 60 * 60 * 24));
                
                const categorySet = new Set(purchases.map(p => p.category));
                const categoryCount = {};
                purchases.forEach(p => {
                    categoryCount[p.category] = (categoryCount[p.category] || 0) + 1;
                });
                const favoriteCategory = Object.keys(categoryCount).reduce((a, b) => 
                    categoryCount[a] > categoryCount[b] ? a : b);
                
                customerData.push({
                    id: i,
                    name: `${surname}${givenName}`,
                    age: age,
                    totalSpent: totalSpent,
                    purchaseCount: purchases.length,
                    avgOrderValue: avgOrderValue,
                    daysSinceLastPurchase: daysSinceLastPurchase,
                    lastPurchaseDate: latestPurchase.toISOString().split('T')[0],
                    categoryDiversity: categorySet.size,
                    productDiversity: new Set(purchases.map(p => p.product)).size,
                    favoriteCategory: favoriteCategory,
                    avgPurchaseInterval: Math.round(365 / purchases.length),
                    recencyScore: 0,
                    frequencyScore: 0,
                    monetaryScore: 0,
                    cluster: null,
                    purchases: purchases
                });
            }
            
            calculateRFMScores(customerData);
            updateStats();
            updateTable();
            runClustering();
        }
        
        // K-means í´ëŸ¬ìŠ¤í„°ë§ ì‹¤í–‰
        function runClustering() {
            const k = parseInt(document.getElementById('clusterCount').value);
            
            const features = customerData.map(customer => [
                (customer.recencyScore || 0) / 5,
                (customer.frequencyScore || 0) / 5,
                (customer.monetaryScore || 0) / 5,
                (customer.categoryDiversity || 1) / 10,
                Math.min((customer.productDiversity || 1) / 20, 1)
            ]);
            
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push([
                    Math.random(),
                    Math.random(),
                    Math.random(),
                    Math.random(),
                    Math.random()
                ]);
            }
            
            let iterations = 0;
            let hasChanged = true;
            
            while (hasChanged && iterations < 100) {
                hasChanged = false;
                iterations++;
                
                customerData.forEach((customer, index) => {
                    let minDistance = Infinity;
                    let closestCluster = 0;
                    
                    centroids.forEach((centroid, clusterIndex) => {
                        const distance = euclideanDistance(features[index], centroid);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCluster = clusterIndex;
                        }
                    });
                    
                    if (customer.cluster !== closestCluster) {
                        hasChanged = true;
                        customer.cluster = closestCluster;
                    }
                });
                
                for (let i = 0; i < k; i++) {
                    const clusterPoints = features.filter((_, index) => customerData[index].cluster === i);
                    if (clusterPoints.length > 0) {
                        centroids[i] = [
                            clusterPoints.reduce((sum, point) => sum + point[0], 0) / clusterPoints.length,
                            clusterPoints.reduce((sum, point) => sum + point[1], 0) / clusterPoints.length,
                            clusterPoints.reduce((sum, point) => sum + point[2], 0) / clusterPoints.length,
                            clusterPoints.reduce((sum, point) => sum + point[3], 0) / clusterPoints.length,
                            clusterPoints.reduce((sum, point) => sum + point[4], 0) / clusterPoints.length
                        ];
                    }
                }
            }
            
            updateStats();
            updateTable();
            updateCharts();
            analyzeClusterCharacteristics();
        }
        
        function euclideanDistance(point1, point2) {
            return Math.sqrt(
                point1.reduce((sum, val, index) => sum + Math.pow(val - point2[index], 2), 0)
            );
        }
        
        // í´ëŸ¬ìŠ¤í„° íŠ¹ì„± ë¶„ì„ (ì§„ì§œ AI ë¶„ì„)
        async function analyzeClusterCharacteristics() {
            const clusters = [...new Set(customerData.map(c => c.cluster))].filter(c => c !== null);
            
            document.getElementById('aiAnalysis').style.display = 'block';
            document.getElementById('clusterAnalysis').innerHTML = '<div class="loading">ğŸ¤– AIê°€ ê° í´ëŸ¬ìŠ¤í„°ë¥¼ ì‹¬ì¸µ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...<br>ì‹¤ì œ êµ¬ë§¤ íŒ¨í„´ê³¼ í–‰ë™ ë°ì´í„°ë¥¼ ì¢…í•©í•˜ì—¬ ì¸ì‚¬ì´íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</div>';
            
            let analysisHTML = '<div class="cluster-cards">';
            
            for (const clusterId of clusters) {
                const clusterData = customerData.filter(c => c.cluster === clusterId);
                const count = clusterData.length;
                const percentage = Math.round(count/customerData.length*100);
                
                const clusterStats = {
                    clusterId: clusterId + 1,
                    count,
                    percentage
                };
                
                // ì‹¤ì œ AI ë¶„ì„ í˜¸ì¶œ
                const analysis = await analyzeClusterWithAI(clusterData, clusterStats);
                
                // í´ëŸ¬ìŠ¤í„° ë©”íŠ¸ë¦­ ê³„ì‚°
                const avgAge = Math.round(clusterData.reduce((sum, c) => sum + c.age, 0) / count);
                const avgSpent = Math.round(clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / count);
                const avgPurchases = Math.round(clusterData.reduce((sum, c) => sum + c.purchaseCount, 0) / count * 10) / 10;
                const avgOrderValue = Math.round(clusterData.reduce((sum, c) => sum + c.avgOrderValue, 0) / count);
                
                analysisHTML += `
                    <div class="cluster-card cluster-${clusterId}">
                        <div class="cluster-title">í´ëŸ¬ìŠ¤í„° ${clusterId + 1}: ${analysis.name}</div>
                        <div class="cluster-subtitle">ê³ ê° ${count}ëª… (${percentage}%)</div>
                        
                        <div class="cluster-metrics">
                            <div class="metric">
                                <div class="metric-value">${avgAge}ì„¸</div>
                                <div class="metric-label">í‰ê·  ì—°ë ¹</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgSpent.toLocaleString()}ì›</div>
                                <div class="metric-label">í‰ê·  êµ¬ë§¤ì•¡</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgPurchases}íšŒ</div>
                                <div class="metric-label">í‰ê·  êµ¬ë§¤íšŸìˆ˜</div>
                            </div>
                            <div class="metric">
                                <div class="metric-value">${avgOrderValue.toLocaleString()}ì›</div>
                                <div class="metric-label">í‰ê·  ì£¼ë¬¸ê°€ê²©</div>
                            </div>
                        </div>
                        
                        <div class="ai-insights">
                            <div class="insight-title">ğŸ§  AI ë¶„ì„ ì¸ì‚¬ì´íŠ¸</div>
                            <div class="insight-text">${analysis.insights}</div>
                        </div>
                        
                        <div class="ai-strategy">
                            <div class="strategy-title">ğŸ¯ ì¶”ì²œ ì•¡ì…˜í”Œëœ</div>
                            <div>${analysis.strategy}</div>
                        </div>
                    </div>
                `;
            }
            
            analysisHTML += '</div>';
            document.getElementById('clusterAnalysis').innerHTML = analysisHTML;
        }
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            const totalCustomers = customerData.length;
            const avgAge = Math.round(customerData.reduce((sum, c) => sum + c.age, 0) / totalCustomers);
            const avgSpent = Math.round(customerData.reduce((sum, c) => sum + c.totalSpent, 0) / totalCustomers);
            const avgPurchases = Math.round(customerData.reduce((sum, c) => sum + c.purchaseCount, 0) / totalCustomers * 10) / 10;
            
            const clusterCounts = {};
            customerData.forEach(c => {
                if (c.cluster !== null) {
                    clusterCounts[c.cluster] = (clusterCounts[c.cluster] || 0) + 1;
                }
            });
            
            const statsHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalCustomers}</div>
                    <div class="stat-label">ì´ ê³ ê° ìˆ˜</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgAge}ì„¸</div>
                    <div class="stat-label">í‰ê·  ì—°ë ¹</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgSpent.toLocaleString()}ì›</div>
                    <div class="stat-label">í‰ê·  êµ¬ë§¤ì•¡</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgPurchases}íšŒ</div>
                    <div class="stat-label">í‰ê·  êµ¬ë§¤íšŸìˆ˜</div>
                </div>
                ${Object.keys(clusterCounts).map(cluster => `
                    <div class="stat-card">
                        <div class="stat-value">${clusterCounts[cluster]}</div>
                        <div class="stat-label">í´ëŸ¬ìŠ¤í„° ${parseInt(cluster) + 1}</div>
                    </div>
                `).join('')}
            `;
            
            document.getElementById('statsGrid').innerHTML = statsHTML;
        }
        
        // í…Œì´ë¸” ì—…ë°ì´íŠ¸
        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = customerData.slice(0, 50).map(customer => `
                <tr class="cluster-${customer.cluster || 0}">
                    <td>${customer.id}</td>
                    <td>${customer.name}</td>
                    <td>${customer.age}ì„¸</td>
                    <td>${customer.totalSpent.toLocaleString()}ì›</td>
                    <td>${customer.purchaseCount}íšŒ</td>
                    <td>${customer.avgOrderValue.toLocaleString()}ì›</td>
                    <td>${customer.favoriteCategory || '-'}</td>
                    <td>R${customer.recencyScore || 0}F${customer.frequencyScore || 0}M${customer.monetaryScore || 0}</td>
                    <td>${customer.cluster !== null ? `í´ëŸ¬ìŠ¤í„° ${customer.cluster + 1}` : '-'}</td>
                </tr>
            `).join('');
        }
        
        // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateCharts() {
            const colors = ['#FF6B6B', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'];
            
            const scatterData = {
                datasets: []
            };
            
            const clusters = [...new Set(customerData.map(c => c.cluster))].filter(c => c !== null);
            clusters.forEach(cluster => {
                const clusterData = customerData.filter(c => c.cluster === cluster);
                scatterData.datasets.push({
                    label: `í´ëŸ¬ìŠ¤í„° ${cluster + 1}`,
                    data: clusterData.map(c => ({ x: c.age, y: c.totalSpent })),
                    backgroundColor: colors[cluster],
                    borderColor: colors[cluster],
                    pointBorderWidth: 2,
                    pointRadius: 4
                });
            });
            
            if (scatterChart) scatterChart.destroy();
            scatterChart = new Chart(document.getElementById('scatterChart'), {
                type: 'scatter',
                data: scatterData,
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'ì—°ë ¹ë³„ ì´ êµ¬ë§¤ê¸ˆì•¡ ë¶„í¬'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'ì—°ë ¹'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'ì´ êµ¬ë§¤ê¸ˆì•¡ (ì›)'
                            }
                        }
                    }
                }
            });
            
            const clusterAvgs = {};
            clusters.forEach(cluster => {
                const clusterData = customerData.filter(c => c.cluster === cluster);
                clusterAvgs[cluster] = clusterData.reduce((sum, c) => sum + c.totalSpent, 0) / clusterData.length;
            });
            
            if (barChart) barChart.destroy();
            barChart = new Chart(document.getElementById('barChart'), {
                type: 'bar',
                data: {
                    labels: clusters.map(c => `í´ëŸ¬ìŠ¤í„° ${c + 1}`),
                    datasets: [{
                        label: 'í‰ê·  êµ¬ë§¤ê¸ˆì•¡',
                        data: clusters.map(c => clusterAvgs[c]),
                        backgroundColor: clusters.map(c => colors[c]),
                        borderColor: clusters.map(c => colors[c]),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'í´ëŸ¬ìŠ¤í„°ë³„ í‰ê·  êµ¬ë§¤ê¸ˆì•¡'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'í‰ê·  êµ¬ë§¤ê¸ˆì•¡ (ì›)'
                            }
                        }
                    }
                }
            });
        }
        
        // CSV ë‹¤ìš´ë¡œë“œ
        function downloadCSV() {
            const headers = ['ê³ ê°ID', 'ì´ë¦„', 'ì—°ë ¹', 'ì´êµ¬ë§¤ê¸ˆì•¡', 'êµ¬ë§¤íšŸìˆ˜', 'í‰ê· ì£¼ë¬¸ê°€ê²©', 'ì„ í˜¸ì¹´í…Œê³ ë¦¬', 'RFMì ìˆ˜', 'í´ëŸ¬ìŠ¤í„°'];
            const csvContent = [
                headers.join(','),
                ...customerData.map(customer => [
                    customer.id,
                    customer.name,
                    customer.age,
                    customer.totalSpent,
                    customer.purchaseCount,
                    customer.avgOrderValue,
                    customer.favoriteCategory || '',
                    `R${customer.recencyScore}F${customer.frequencyScore}M${customer.monetaryScore}`,
                    customer.cluster !== null ? customer.cluster + 1 : ''
                ].join(','))
            ].join('\n');
            
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'ai_customer_clustering_results.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // CSV í…œí”Œë¦¿ ë‹¤ìš´ë¡œë“œ
        function downloadTemplate() {
            const templateData = [
                {
                    'ê³ ê°ID': 1,
                    'ì´ë¦„': 'ê¹€ë¯¼ìˆ˜',
                    'ì—°ë ¹': 35,
                    '1íšŒêµ¬ë§¤ê°€ê²©': 15000,
                    'êµ¬ë§¤ìƒí’ˆ': 'ë‹¹ê·¼',
                    'ì¹´í…Œê³ ë¦¬': 'ì±„ì†Œ',
                    'êµ¬ë§¤ì¼': '2024-03-15'
                },
                {
                    'ê³ ê°ID': 1,
                    'ì´ë¦„': 'ê¹€ë¯¼ìˆ˜',
                    'ì—°ë ¹': 35,
                    '1íšŒêµ¬ë§¤ê°€ê²©': 8000,
                    'êµ¬ë§¤ìƒí’ˆ': 'ì‹œê¸ˆì¹˜',
                    'ì¹´í…Œê³ ë¦¬': 'ì±„ì†Œ',
                    'êµ¬ë§¤ì¼': '2024-03-20'
                },
                {
                    'ê³ ê°ID': 2,
                    'ì´ë¦„': 'ì´ì˜í¬',
                    'ì—°ë ¹': 28,
                    '1íšŒêµ¬ë§¤ê°€ê²©': 12000,
                    'êµ¬ë§¤ìƒí’ˆ': 'ê¹€ë°¥',
                    'ì¹´í…Œê³ ë¦¬': 'ì¦‰ì„ì‹í’ˆ',
                    'êµ¬ë§¤ì¼': '2024-04-10'
                }
            ];
            
            const headers = Object.keys(templateData[0]);
            const csvContent = [
                headers.join(','),
                ...templateData.map(row => headers.map(header => `"${row[header]}"`).join(','))
            ].join('\n');
            
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'purchase_history_template.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // ì´ˆê¸° ë°ì´í„° ìƒì„±
        generateData();
    </script>
</body>
</html>
